<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Piggy Planet 3.5 (Ultimate Edition)</title>
    <style>
        /* --- Âü∫Á°ÄËÆæÁΩÆ --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; opacity: 0; transition: opacity 2s ease; }
        
        /* --- 1. Á≤âËâ≤Á§ºÁõíÂú∫ÊôØ --- */
        #intro-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1s;
        }
        .gift-box {
            font-size: 80px; cursor: pointer;
            animation: bounce 2s infinite;
            filter: drop-shadow(0 0 20px #FF69B4);
            transition: transform 0.3s;
        }
        .gift-box:hover { transform: scale(1.1); }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-20px); } }

        /* --- 2. ÊòüÁêÉÂ§ßÊàòÂ≠óÂπïÂú∫ÊôØ --- */
        #starwars-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 90;
            display: none; overflow: hidden; perspective: 400px;
        }
        .stars-bg {
            position: absolute; width: 100%; height: 100%;
            background: url('https://images.unsplash.com/photo-1506318137071-a8bcbf6755dd?q=80&w=2070&auto=format&fit=crop') center/cover;
            opacity: 0.5;
        }
        .intro-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #4BD5EE; font-size: 1.5rem; width: 80%; text-align: center;
            opacity: 0; transition: opacity 1s;
        }
        .crawl-container {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            transform-origin: 50% 100%; transform: rotateX(25deg);
            display: flex; justify-content: center; opacity: 0; transition: opacity 1s;
        }
        .crawl-content {
            position: absolute; top: 100%; width: 80%; max-width: 600px;
            color: #FFD700; font-weight: bold; text-align: justify;
            font-size: 2rem; line-height: 1.5; letter-spacing: 0.1em;
            animation: crawl 25s linear forwards; 
        }
        .crawl-content h1 { text-align: center; font-size: 1.2em; margin-bottom: 0.5em; }
        .crawl-content p { margin-bottom: 1em; }
        @keyframes crawl { 0% { top: 100%; opacity: 1; } 90% { opacity: 1; } 100% { top: -150%; opacity: 0; } }
        .skip-btn {
            position: absolute; bottom: 30px; right: 30px;
            color: #555; border: 1px solid #555; padding: 5px 15px;
            cursor: pointer; z-index: 101; font-size: 0.8rem; background: transparent;
        }
        .skip-btn:hover { color: #fff; border-color: #fff; }

        /* --- 3. UI Overlay --- */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #FFB7C5; pointer-events: none; text-shadow: 0 0 10px #FF69B4;
            display: none; 
        }
        h1 { margin: 0; font-weight: 800; letter-spacing: 2px; text-transform: uppercase; font-size: 1.8rem; background: linear-gradient(to right, #FFB7C5, #E0B0FF); -webkit-background-clip: text; color: transparent; }
        .status { margin-top: 5px; font-size: 0.9rem; color: #E6E6FA; }
        .status span { color: #FFF; font-weight: bold; }

        #video-preview { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; border-radius: 20px; border: 3px solid #FFB7C5; box-shadow: 0 0 20px rgba(255, 105, 180, 0.4); z-index: 10; transform: scaleX(-1); opacity: 0.8; object-fit: cover; display: none; }
        
        #controls { position: absolute; bottom: 20px; left: 20px; z-index: 20; pointer-events: auto; display: none; gap: 10px; flex-wrap: wrap; max-width: 70%;}
        
        button, .btn-upload { font-family: inherit; transition: all 0.2s; outline: none; }
        .btn-upload { background: linear-gradient(135deg, #FF69B4, #FFB7C5); border: none; padding: 12px 24px; color: #fff; font-weight: bold; border-radius: 50px; cursor: pointer; box-shadow: 0 5px 15px rgba(255, 105, 180, 0.4); font-size: 0.9rem; display: inline-block;}
        .btn-upload:hover { transform: scale(1.05); }
        
        .btn-save { background: linear-gradient(135deg, #00FFFF, #1E90FF); border: none; padding: 12px 24px; color: #000; font-weight: bold; border-radius: 50px; cursor: pointer; box-shadow: 0 5px 15px rgba(0, 255, 255, 0.4); font-size: 0.9rem; }
        .btn-save:hover { transform: scale(1.05); box-shadow: 0 0 20px #00FFFF; }

        .btn-cam { background: linear-gradient(135deg, #00FF99, #32CD32); border: none; padding: 12px 24px; color: #000; font-weight: bold; border-radius: 50px; cursor: pointer; box-shadow: 0 5px 15px rgba(0, 255, 153, 0.4); font-size: 0.9rem; }
        .btn-cam:hover { transform: scale(1.05); box-shadow: 0 0 20px #00FF99; }
        .btn-cam.active { background: linear-gradient(135deg, #ff4444, #cc0000); color: white; box-shadow: 0 5px 15px rgba(255, 0, 0, 0.4); }

        .btn-retry { background: rgba(255,255,255,0.1); border: 1px solid #FFB7C5; color: #FFB7C5; padding: 10px; border-radius: 50px; cursor: pointer; display: none; }
        input[type="file"] { display: none; }
        
        /* Workbench & Panels */
        #workbench { position: absolute; top: 70px; right: 20px; width: 260px; background: rgba(20, 10, 30, 0.85); border: 2px solid #FFB7C5; border-radius: 15px; padding: 15px; z-index: 20; color: #FFB7C5; backdrop-filter: blur(10px); font-family: sans-serif; transition: all 0.3s ease; box-shadow: 0 0 20px rgba(0,0,0,0.5); display: none; }
        #workbench h3 { margin: 0 0 15px 0; font-size: 1rem; border-bottom: 1px solid rgba(255,183,197,0.3); padding-bottom: 5px; text-align: center;}
        
        /* ÂàÜÈöîÁ∫øÊ†∑Âºè */
        .separator { border-bottom: 1px dashed rgba(255, 183, 197, 0.3); margin: 10px 0; }
        
        .control-group { margin-bottom: 12px; }
        .control-group label { display: flex; justify-content: space-between; font-size: 0.8rem; margin-bottom: 5px; }
        input[type=range] { width: 100%; accent-color: #FF69B4; cursor: pointer; }
        
        #photo-workbench { position: absolute; top: 50%; right: 20px; transform: translateY(-50%); width: 220px; background: rgba(40, 20, 60, 0.8); border: 2px solid #FFF; border-radius: 15px; padding: 15px; z-index: 20; color: #FFF; font-family: sans-serif; backdrop-filter: blur(5px); display: none; }
        #btn-toggle-wb { position: absolute; top: 20px; right: 20px; width: 40px; height: 40px; border-radius: 50%; background: rgba(20, 10, 30, 0.6); border: 2px solid #FFB7C5; color: #FFB7C5; font-size: 1.2rem; cursor: pointer; z-index: 21; display: none; align-items: center; justify-content: center; transition: all 0.3s; box-shadow: 0 0 10px rgba(255, 105, 180, 0.3); }
        #btn-toggle-wb:hover { background: #FFB7C5; color: #220022; transform: rotate(90deg); }
        
        /* Loading Overlay for Processing */
        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 200; display: none; justify-content: center; align-items: center; color: #FFB7C5; flex-direction: column;}
        .spinner { width: 50px; height: 50px; border: 5px solid #FFB7C5; border-top: 5px solid transparent; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text">Ê≠£Âú®Â§ÑÁêÜÁÖßÁâá... (0/0)</div>
    </div>

    <!-- 1. Á§ºÁõíÂºÄÂú∫ -->
    <div id="intro-layer">
        <div class="gift-box" id="start-gift-btn">üéÅ</div>
    </div>

    <!-- 2. ÊòüÁêÉÂ§ßÊàòÂ≠óÂπï -->
    <div id="starwars-layer">
        <div class="stars-bg"></div>
        <div class="intro-text" id="sw-intro-text">
            A long time ago in a galaxy far, far away....
        </div>
        <div class="crawl-container" id="sw-crawl-container" style="opacity: 0;">
            <div class="crawl-content" id="crawl-text">
                <h1>EPISODE I</h1>
                <h2>THE PIGGY AWAKENS</h2>
                <p>A long time ago... there was a mysterious, mist-shrouded planet.</p>
                <p>It floated in the deep pink nebula, guarded by an ancient Kitten Spirit and a loyal Piggy Satellite.</p>
                <p>Legend has it that this planet holds the most precious memories of the universe...</p>
                <p>Now, the force is strong with you. Use your hands to unlock the magic...</p>
            </div>
        </div>
        <button class="skip-btn" id="skip-intro-btn">SKIP >></button>
    </div>

    <!-- 3. Áå™Âí™ÊòüÁêÉ‰∏ªÁïåÈù¢ -->
    <div id="ui-layer">
        <h1>üê∑ Piggy Planet 3.5 üê±</h1>
        <div class="status">STATUS: <span id="sys-status">Initializing...</span></div>
        <div class="status">HANDS: <span id="gesture-state">Searching...</span></div>
    </div>
    
    <button id="btn-toggle-wb" title="ÂàáÊç¢ÊéßÂà∂Âè∞">‚öôÔ∏è</button>

    <div id="workbench">
        <h3>‚ú® Áå™Âí™ÊÄªÊéßÂè∞ ‚ú®</h3>
        <div class="control-group">
            <label style="color:#FFF; font-weight:bold;">üåü Êï¥‰Ωì‰∫ÆÂ∫¶ (Master)<span id="val-master">1.0</span></label>
            <input type="range" id="sl-master" min="0" max="2" step="0.1" value="1.0">
        </div>
        <div class="separator"></div>
        <div class="control-group"><label>ÊØõÁªí‰∫ÆÂ∫¶ (Glow)<span id="val-plush">0.5</span></label><input type="range" id="sl-plush" min="0" max="2" step="0.1" value="0.5"></div>
        <div class="control-group"><label>Áå´Âí™‰∫ÆÂ∫¶ (Core)<span id="val-kitten">0.5</span></label><input type="range" id="sl-kitten" min="0" max="2" step="0.1" value="0.5"></div>
        <div class="control-group"><label>Â∞èÁå™Â§ßÂ∞è (Piggy)<span id="val-piggy">1.0</span></label><input type="range" id="sl-piggy" min="0.5" max="3" step="0.1" value="1.0"></div>
        <div class="control-group"><label>‰∫ëÊúµ‰∫ÆÂ∫¶ (Clouds)<span id="val-cloud">0.8</span></label><input type="range" id="sl-cloud" min="0" max="2" step="0.1" value="0.8"></div>
        <div class="control-group"><label>ÂΩ©ËôπÂº∫Â∫¶ (Rainbow)<span id="val-rainbow">1.5</span></label><input type="range" id="sl-rainbow" min="0.5" max="3" step="0.1" value="1.5"></div>
        <div class="control-group"><label>ÁéØÂ¢ÉÂÖâÁÖß (Ambient)<span id="val-env">2.0</span></label><input type="range" id="sl-env" min="0" max="4" step="0.1" value="2.0"></div>
        <div class="control-group"><label>Ëá™ËΩ¨ÈÄüÂ∫¶ (Spin)<span id="val-spin">0.5</span></label><input type="range" id="sl-spin" min="0" max="2" step="0.1" value="0.5"></div>
    </div>

    <div id="photo-workbench">
        <div style="text-align:center; margin-bottom:10px; font-weight:bold;">‚ú® Ë°•ÂÖâÁÅØ ‚ú®</div>
        <div class="control-group"><label>‰∫ÆÂ∫¶<span id="val-photo-bright">0.8</span></label><input type="range" id="slider-photo-bright" min="0" max="2" step="0.05" value="0.8"></div>
        <div class="control-group"><label>ÁéØÂ¢É<span id="val-photo-exp">0.8</span></label><input type="range" id="slider-photo-exp" min="0" max="2" step="0.1" value="0.8"></div>
    </div>

    <div id="controls">
        <label class="btn-upload">‰∏ä‰º†ÁÖßÁâá<input type="file" id="image-upload" multiple accept="image/*"></label>
        <button class="btn-save" id="btn-save-page">üíæ ‰øùÂ≠òÁΩëÈ°µ</button>
        <button id="btn-start-cam" class="btn-cam">üì∑ ÂêØÂä®ÊëÑÂÉèÂ§¥</button>
        <button id="btn-retry-cam" class="btn-retry">ÈáçËØïÊëÑÂÉèÂ§¥</button>
    </div>

    <video id="video-preview" playsinline muted autoplay></video>
    <div id="canvas-container"></div>
    
    <audio id="bgm" loop>
        <source src="https://cdn.pixabay.com/download/audio/2022/03/24/audio_07823d069c.mp3?filename=space-120280.mp3" type="audio/mpeg">
    </audio>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import TWEEN from 'three/addons/libs/tween.module.js';

        // --- Data Persistence ---
        window.EMBEDDED_PHOTOS = [];

        // --- Configuration ---
        const CONFIG = {
            particleCount: 2600, orbitCount: 1200, starCount: 4000, rainbowCount: 800, cloudCount: 600,
            planetRadius: 28, orbitRadius: 45, cloudOrbitRadius: 70, 
            colors: [0xFFC0CB, 0xFFB7C5, 0xFF69B4, 0xFFFFFF, 0xFFE4E1], 
            plushBrightness: 0.5, kittenBrightness: 0.5, piggyScale: 1.0, cloudBrightness: 0.8,
            rainbowIntensity: 1.5, ambientIntensity: 2.0, spinSpeed: 0.5,
            masterBrightness: 1.0,
            bloomStrengthNormal: 1.2, bloomStrengthPhoto: 0.2, bloomThreshold: 0.3, bloomRadius: 0.5,
            pinchStart: 0.06, pinchEnd: 0.10, photoHoverDist: 22, 
            camRotSensitivity: 0.02, camDeadZone: 0.2, cursorDistance: 40,
            photoBrightnessNormal: 1.0, photoBrightnessDim: 0.8, exposureNormal: 1.2, exposurePhoto: 0.8        
        };

        // --- Global Variables ---
        let scene, camera, renderer, composer, controls;
        let contentGroup, orbitGroup, starGroup, coreGroup, satelliteGroup;
        let particleMeshes = [], orbitMeshes = [], photoObjects = [];
        let cursorMesh, ambientLight;
        let bloomPass;
        let dummy = new THREE.Object3D();
        let cachedPlushTexture = null; 

        const raycaster = new THREE.Raycaster();
        const targetHandPointer = new THREE.Vector2(-999, -999);
        const smoothHandPointer = new THREE.Vector2(-999, -999);
        const STATE = { PLANET: 'planet', EXPLODE: 'explode', PHOTO: 'photo' };
        let currentState = STATE.PLANET; let previousState = STATE.PLANET; 
        let isTransitioning = false; let hoveredPhoto = null, grabbedPhoto = null, isPinching = false;
        let planetPositions = [], explodePositions = [];
        let videoElement, hands, cameraPipe; let handCentroid = new THREE.Vector2();
        let mediaPipeInitializing = false;
        let isCamActive = false;
        let lastStateChangeTime = 0;

        // --- Image Compression Tool ---
        function compressImage(file, quality = 0.6, maxWidth = 512) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;

                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }

                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve(canvas.toDataURL('image/jpeg', quality));
                    };
                };
            });
        }

        // --- Save Functionality ---
        function savePage() {
            if (window.EMBEDDED_PHOTOS.length === 0) {
                if(!confirm("ËøòÊ≤°‰∏ä‰º†ÁÖßÁâáÂì¶ÔºåÁ°ÆÂÆöË¶Å‰øùÂ≠òÁ©∫ÊòüÁêÉÂêóÔºü")) return;
            }
            let html = document.documentElement.outerHTML;
            const dataString = JSON.stringify(window.EMBEDDED_PHOTOS);
            html = html.replace(/window\.EMBEDDED_PHOTOS\s*=\s*\[[\s\S]*?\];?/, `window.EMBEDDED_PHOTOS = ${dataString};`);
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'piggy_planet_gift.html';
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            alert("ÁΩëÈ°µÂ∑≤‰øùÂ≠òÔºÅ\nÁÖßÁâáÂ∑≤Ëá™Âä®ÂéãÁº©ÔºåÊñá‰ª∂‰ΩìÁßØÂ∑≤‰ºòÂåñ„ÄÇ");
        };

        // --- Intro Logic ---
        function openGift() {
            const bgm = document.getElementById('bgm');
            bgm.volume = 0.5;
            bgm.play().catch(e => console.log("Audio autoplay blocked"));
            document.getElementById('intro-layer').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('intro-layer').style.display = 'none';
                startStarWarsIntro();
            }, 1000);
        };

        function startStarWarsIntro() {
            const layer = document.getElementById('starwars-layer');
            const introText = document.getElementById('sw-intro-text');
            const crawlContainer = document.getElementById('sw-crawl-container');
            layer.style.display = 'block';
            setTimeout(() => { introText.style.opacity = 1; }, 500);
            setTimeout(() => {
                introText.style.opacity = 0;
                setTimeout(() => { crawlContainer.style.opacity = 1; }, 1000);
            }, 4000); 
        }

        function endIntro() {
            const swLayer = document.getElementById('starwars-layer');
            const canvasContainer = document.getElementById('canvas-container');
            const uiLayer = document.getElementById('ui-layer');
            const controls = document.getElementById('controls');
            const preview = document.getElementById('video-preview');
            const btnTog = document.getElementById('btn-toggle-wb');
            swLayer.style.opacity = 0;
            setTimeout(() => {
                swLayer.style.display = 'none';
                if(!window.is3DInitialized) { window.is3DInitialized = true; init3DWorld(); }
                canvasContainer.style.opacity = 1;
                uiLayer.style.display = 'block';
                controls.style.display = 'flex';
                preview.style.display = 'block';
                btnTog.style.display = 'flex';
            }, 1000);
        };

        function cleanUpGroup(group) {
            if (!group) return;
            for (let i = group.children.length - 1; i >= 0; i--) {
                const child = group.children[i];
                cleanUpGroup(child); 
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) { child.material.forEach(mat => mat.dispose()); } 
                    else { child.material.dispose(); }
                }
                group.remove(child);
            }
        }

        // --- Photo Handling (Updated for 100 Photos) ---
        async function handleImageUpload(event) {
            const files = Array.from(event.target.files);
            if (!files.length) return;
            
            const loaderOverlay = document.getElementById('loading-overlay');
            const loaderText = document.getElementById('loading-text');
            loaderOverlay.style.display = 'flex';
            
            photoObjects.forEach(obj => { contentGroup.remove(obj); cleanUpGroup(obj); });
            photoObjects = []; window.EMBEDDED_PHOTOS = [];
            
            const loader = new THREE.TextureLoader();
            
            for (let i = 0; i < files.length; i++) {
                loaderText.innerText = `Ê≠£Âú®ÂéãÁº©Â§ÑÁêÜÁÖßÁâá... (${i+1}/${files.length})`;
                const compressedBase64 = await compressImage(files[i]);
                window.EMBEDDED_PHOTOS.push(compressedBase64);
                
                await new Promise(resolve => {
                    loader.load(compressedBase64, (texture) => {
                        createPhotoFrame(texture, i, files.length); 
                        resolve();
                    });
                });
            }
            
            loaderOverlay.style.display = 'none';
        }
        
        function loadEmbeddedPhotos() {
            if (window.EMBEDDED_PHOTOS && window.EMBEDDED_PHOTOS.length > 0) {
                const loader = new THREE.TextureLoader();
                const total = window.EMBEDDED_PHOTOS.length;
                window.EMBEDDED_PHOTOS.forEach((data, index) => {
                    loader.load(data, (texture) => {
                        createPhotoFrame(texture, index, total);
                    });
                });
            }
        }

        function createPhotoFrame(texture, index, totalCount = 1) {
            texture.colorSpace = THREE.SRGBColorSpace;
            const img = texture.image;
            let width = 8; let height = 8; const maxDim = 9;

            if (img.width && img.height) {
                const aspect = img.width / img.height;
                if (aspect >= 1) { width = maxDim; height = maxDim / aspect; } 
                else { height = maxDim; width = maxDim * aspect; }
            }

            const photoGeo = new THREE.PlaneGeometry(width, height);
            const photoMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, color: new THREE.Color().setScalar(CONFIG.photoBrightnessNormal) });
            const photoMesh = new THREE.Mesh(photoGeo, photoMat); photoMesh.name = "photo_surface"; 
            
            const frameGroup = new THREE.Group(); frameGroup.add(photoMesh);
            
            const plushTex = getPlushTexture(); 
            const frameMat = new THREE.MeshPhysicalMaterial({ color: 0xFFB7C5, roughness: 1.0, metalness: 0.0, bumpMap: plushTex, bumpScale: 0.5, sheen: 1.0, sheenColor: 0xFFE4E1, sheenRoughness: 1.0, clearcoat: 0.0 });
            
            const thickness = 0.5; const depth = 0.3; const w = width; const h = height;
            const topBar = new THREE.Mesh(new THREE.BoxGeometry(w+thickness*2, thickness, depth), frameMat); topBar.position.y = h/2+thickness/2;
            const bottomBar = new THREE.Mesh(new THREE.BoxGeometry(w+thickness*2, thickness, depth), frameMat); bottomBar.position.y = -h/2-thickness/2;
            const leftBar = new THREE.Mesh(new THREE.BoxGeometry(thickness, h, depth), frameMat); leftBar.position.x = -w/2-thickness/2;
            const rightBar = new THREE.Mesh(new THREE.BoxGeometry(thickness, h, depth), frameMat); rightBar.position.x = w/2+thickness/2;
            
            [topBar, bottomBar, leftBar, rightBar].forEach(b => { b.name = "frame_border"; b.castShadow = true; b.receiveShadow = true; frameGroup.add(b); });
            
            const phi = Math.acos(1 - 2 * (index + 0.5) / totalCount);
            const theta = Math.PI * (1 + Math.sqrt(5)) * (index + 0.5);
            
            const baseRadius = 60; 
            const radiusStep = totalCount > 50 ? 0.3 : 0; 
            const r = baseRadius + (index % 3) * 5 + (totalCount * 0.1); 

            frameGroup.position.x = r * Math.sin(phi) * Math.cos(theta);
            frameGroup.position.y = r * Math.sin(phi) * Math.sin(theta);
            frameGroup.position.z = r * Math.cos(phi);
            
            frameGroup.lookAt(0,0,0);
            frameGroup.userData = { originalPos: frameGroup.position.clone(), originalRot: frameGroup.rotation.clone(), id: index, baseScale: 1.0 };
            
            if(currentState === STATE.PLANET) frameGroup.scale.set(0,0,0);
            
            contentGroup.add(frameGroup); photoObjects.push(frameGroup);
        }

        function getPlushTexture() {
            if (cachedPlushTexture) return cachedPlushTexture;
            const size = 512; const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d'); ctx.fillStyle = '#808080'; ctx.fillRect(0, 0, size, size);
            const imgData = ctx.getImageData(0, 0, size, size); const data = imgData.data;
            for(let i = 0; i < data.length; i += 4) { const val = 128 + (Math.random() - 0.5) * 50; data[i] = val; data[i+1] = val; data[i+2] = val; }
            ctx.putImageData(imgData, 0, 0); 
            cachedPlushTexture = new THREE.CanvasTexture(canvas); cachedPlushTexture.wrapS = THREE.RepeatWrapping; cachedPlushTexture.wrapT = THREE.RepeatWrapping; return cachedPlushTexture;
        }

        function createKittenCore() {
            cleanUpGroup(coreGroup); if(coreGroup) contentGroup.remove(coreGroup); coreGroup = new THREE.Group();
            const r = CONFIG.planetRadius * 0.5; const plushTex = getPlushTexture();
            const matPink = new THREE.MeshPhysicalMaterial({ color: 0xFFB7C5, roughness: 0.8, bumpMap: plushTex, bumpScale: 0.2, emissive: 0xFF69B4, emissiveIntensity: CONFIG.kittenBrightness * CONFIG.masterBrightness, sheen: 1.0, sheenColor: 0xFFFFFF, sheenRoughness: 0.5 });
            const matDarkPink = new THREE.MeshStandardMaterial({ color: 0xFF1493 }); const matBlack = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.1 }); const matWhite = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            const head = new THREE.Mesh(new THREE.SphereGeometry(r, 64, 64), matPink); head.castShadow = true; head.receiveShadow = true; coreGroup.add(head);
            const earGeo = new THREE.ConeGeometry(r*0.35, r*0.5, 32); const e1 = new THREE.Mesh(earGeo, matPink); e1.position.set(-r*0.5, r*0.75, 0); e1.rotation.z = 0.4; e1.rotation.x = -0.1; e1.castShadow = true; const e2 = new THREE.Mesh(earGeo, matPink); e2.position.set(r*0.5, r*0.75, 0); e2.rotation.z = -0.4; e2.rotation.x = -0.1; e2.castShadow = true; coreGroup.add(e1); coreGroup.add(e2);
            const eyeGeo = new THREE.SphereGeometry(r*0.18, 32, 32); const eyeL = new THREE.Mesh(eyeGeo, matBlack); eyeL.position.set(-r*0.4, r*0.1, r*0.82); const spL = new THREE.Mesh(new THREE.SphereGeometry(r*0.06), matWhite); spL.position.set(r*0.08, r*0.08, r*0.15); eyeL.add(spL); coreGroup.add(eyeL); const eyeR = new THREE.Mesh(eyeGeo, matBlack); eyeR.position.set(r*0.4, r*0.1, r*0.82); const spR = new THREE.Mesh(new THREE.SphereGeometry(r*0.06), matWhite); spR.position.set(r*0.08, r*0.08, r*0.15); eyeR.add(spR); coreGroup.add(eyeR);
            const cheekGeo = new THREE.SphereGeometry(r*0.15); const matBlush = new THREE.MeshBasicMaterial({ color: 0xFF69B4, transparent: true, opacity: 0.6 }); const cheekL = new THREE.Mesh(cheekGeo, matBlush); cheekL.position.set(-r*0.55, -r*0.15, r*0.75); coreGroup.add(cheekL); const cheekR = new THREE.Mesh(cheekGeo, matBlush); cheekR.position.set(r*0.55, -r*0.15, r*0.75); coreGroup.add(cheekR);
            const whiskerMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8 }); const whiskerGeo = new THREE.CylinderGeometry(0.1, 0.05, r*0.8, 8); whiskerGeo.translate(0, r*0.4, 0); whiskerGeo.rotateZ(Math.PI/2);
            const createWhiskerSide = (isLeft) => { const group = new THREE.Group(); const sign = isLeft ? 1 : -1; group.position.set(sign * r * 0.6, -r * 0.05, r * 0.7); group.rotation.y = sign * 0.3; for(let i=-1; i<=1; i++) { const w = new THREE.Mesh(whiskerGeo, whiskerMat); w.rotation.z = i * 0.2 + (isLeft ? 0 : Math.PI); w.rotation.y = (Math.random()-0.5) * 0.2; group.add(w); } return group; }; coreGroup.add(createWhiskerSide(true)); coreGroup.add(createWhiskerSide(false));
            const nose = new THREE.Mesh(new THREE.CapsuleGeometry(r*0.06, r*0.1, 4, 8), matDarkPink); nose.rotation.z = Math.PI/2; nose.position.set(0, -r*0.05, r*0.95); coreGroup.add(nose);
            contentGroup.add(coreGroup);
        }

        function createPlanetParticles() {
            particleMeshes.forEach(m => { contentGroup.remove(m); if(m.geometry) m.geometry.dispose(); if(m.material) m.material.dispose(); }); particleMeshes = []; planetPositions = []; explodePositions = [];
            const plushTex = getPlushTexture();
            const matSphere = new THREE.MeshPhysicalMaterial({ color: 0xFFFFFF, roughness: 0.9, bumpMap: plushTex, bumpScale: 0.2, emissive: 0xFF69B4, emissiveIntensity: CONFIG.plushBrightness * CONFIG.masterBrightness, sheen: 1.0, sheenColor: 0xFFC0CB });
            const matBox = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.4, metalness: 0.3, emissive: 0x442244, emissiveIntensity: 0.2 });
            const sphereGeo = new THREE.IcosahedronGeometry(0.9, 1); const boxGeo = new THREE.BoxGeometry(1.3, 1.3, 1.3);      
            const sphereCount = Math.floor(CONFIG.particleCount * 0.7); const boxCount = CONFIG.particleCount - sphereCount;
            const meshSphere = new THREE.InstancedMesh(sphereGeo, matSphere, sphereCount); meshSphere.castShadow = true; meshSphere.receiveShadow = true;
            const meshBox = new THREE.InstancedMesh(boxGeo, matBox, boxCount); meshBox.castShadow = true; meshBox.receiveShadow = true;
            meshSphere.userData = { type: 'sphere' }; meshBox.userData = { type: 'box' }; const meshes = [meshSphere, meshBox]; const counts = [sphereCount, boxCount]; const color = new THREE.Color();
            const phi = Math.PI * (3 - Math.sqrt(5)); const total = CONFIG.particleCount; let allPos = [];
            for(let i=0; i<total; i++) { const y = 1 - (i / (total - 1)) * 2; const radiusAtY = Math.sqrt(1 - y * y); const theta = phi * i; const x = Math.cos(theta) * radiusAtY; const z = Math.sin(theta) * radiusAtY; const r = CONFIG.planetRadius + (Math.random() - 0.5) * 2.0; allPos.push(new THREE.Vector3(x*r, y*r, z*r)); }
            const indices = Array.from({length: total}, (_, i) => i); for(let i=indices.length-1; i>0; i--) { const j = Math.floor(Math.random() * (i+1)); [indices[i], indices[j]] = [indices[j], indices[i]]; }
            let offset = 0;
            meshes.forEach((mesh, idx) => { const count = counts[idx]; for(let i=0; i<count; i++) { const pIdx = indices[offset + i]; const pos = allPos[pIdx]; planetPositions.push(pos); const rExp = 50 + Math.random() * 50; explodePositions.push(pos.clone().normalize().multiplyScalar(rExp)); dummy.position.copy(pos); dummy.scale.setScalar(Math.random()*0.5 + 0.5); dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI); dummy.updateMatrix(); mesh.setMatrixAt(i, dummy.matrix); const hex = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)]; color.setHex(hex); mesh.setColorAt(i, color); } offset += count; contentGroup.add(mesh); particleMeshes.push(mesh); });
        }

        function createOrbitParticles() {
            cleanUpGroup(orbitGroup); orbitMeshes = [];
            const geo = new THREE.BoxGeometry(0.8, 0.8, 0.8); const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 * CONFIG.rainbowIntensity * 0.5 * CONFIG.masterBrightness, blending: THREE.AdditiveBlending });
            const rainbowMesh = new THREE.InstancedMesh(geo, mat, CONFIG.rainbowCount); const colors = [0xFF0000, 0xFFA500, 0xFFFF00, 0x00FF00, 0x00FFFF, 0x0000FF, 0x8B00FF]; const col = new THREE.Color();
            for(let i=0; i<CONFIG.rainbowCount; i++) { const t = i / CONFIG.rainbowCount; const angle = t * Math.PI * 2; const r = CONFIG.orbitRadius + (Math.random()-0.5) * 6; const x = Math.cos(angle) * r; const z = Math.sin(angle) * r; const y = Math.sin(angle * 3) * 5 + (Math.random()-0.5)*2; dummy.position.set(x, y, z); dummy.scale.setScalar(Math.random() * 1.5 + 0.5); dummy.rotation.set(Math.random(), Math.random(), Math.random()); dummy.updateMatrix(); rainbowMesh.setMatrixAt(i, dummy.matrix); const cIdx = Math.floor(t * colors.length); col.setHex(colors[cIdx]); col.lerp(new THREE.Color(0xFFFFFF), 0.3); rainbowMesh.setColorAt(i, col); } orbitGroup.add(rainbowMesh); orbitMeshes.push(rainbowMesh);
            const cloudMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 1, flatShading: false, transparent: true, opacity: 0.8, emissive: 0xFFFFFF, emissiveIntensity: CONFIG.cloudBrightness * CONFIG.masterBrightness }); const cloudGeo = new THREE.SphereGeometry(2.5, 8, 8); const cloudsTotal = CONFIG.cloudCount * 5; const cloudMesh = new THREE.InstancedMesh(cloudGeo, cloudMat, cloudsTotal);
            let idx = 0; for(let i=0; i<CONFIG.cloudCount; i++) { const angle = Math.random() * Math.PI * 2; const rCenter = CONFIG.cloudOrbitRadius; if(Math.random() > 0.4) continue; const centerX = Math.cos(angle) * rCenter; const centerZ = Math.sin(angle) * rCenter; const centerY = (Math.random()-0.5) * 9; const blobs = 4 + Math.floor(Math.random() * 4); for(let j=0; j<blobs; j++) { if(idx >= cloudsTotal) break; const offX = (Math.random()-0.5)*6; const offY = (Math.random()-0.5)*1.8; const offZ = (Math.random()-0.5)*6; dummy.position.set(centerX + offX, centerY + offY, centerZ + offZ); dummy.scale.setScalar(Math.random() * 1.5 + 0.8); dummy.rotation.set(Math.random(), Math.random(), 0); dummy.updateMatrix(); cloudMesh.setMatrixAt(idx, dummy.matrix); cloudMesh.setColorAt(idx, new THREE.Color(0xFFFFFF)); idx++; } } orbitGroup.add(cloudMesh); orbitMeshes.push(cloudMesh);
        }

        function createPiggySatellite() {
            if(satelliteGroup) orbitGroup.remove(satelliteGroup); satelliteGroup = new THREE.Group();
            const size = 3.5; const matPink = new THREE.MeshPhysicalMaterial({ color: 0xFFB7C5, roughness: 0.6, metalness: 0.1, emissive: 0xFFC0CB, emissiveIntensity: 0.2 * CONFIG.masterBrightness, clearcoat: 0.5 }); const matDark = new THREE.MeshStandardMaterial({ color: 0xFF69B4 }); const matBlack = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const body = new THREE.Mesh(new THREE.SphereGeometry(size, 32, 32), matPink); body.castShadow = true; satelliteGroup.add(body);
            const earGeo = new THREE.ConeGeometry(size*0.4, size*0.8, 16); const e1 = new THREE.Mesh(earGeo, matPink); e1.position.set(-size*0.6, size*0.7, 0); e1.rotation.z = 0.5; body.add(e1); const e2 = new THREE.Mesh(earGeo, matPink); e2.position.set(size*0.6, size*0.7, 0); e2.rotation.z = -0.5; body.add(e2);
            const snout = new THREE.Mesh(new THREE.CylinderGeometry(size*0.3, size*0.35, size*0.2, 16), matDark); snout.rotation.x = Math.PI/2; snout.position.set(0, 0, size*0.9); body.add(snout);
            const eye1 = new THREE.Mesh(new THREE.SphereGeometry(size*0.12), matBlack); eye1.position.set(-size*0.4, size*0.2, size*0.85); body.add(eye1); const eye2 = new THREE.Mesh(new THREE.SphereGeometry(size*0.12), matBlack); eye2.position.set(size*0.4, size*0.2, size*0.85); body.add(eye2);
            satelliteGroup.scale.setScalar(CONFIG.piggyScale); orbitGroup.add(satelliteGroup);
        }

        function createStarField() {
            const starGeo = new THREE.BufferGeometry(); const starPos = []; for(let i=0; i<CONFIG.starCount; i++) { const r = 400 + Math.random() * 400; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1); starPos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)); } starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 1.5, transparent: true, opacity: 0.8, sizeAttenuation: true }); const stars = new THREE.Points(starGeo, starMat); starGroup.add(stars);
        }

        function createCursor() {
            const shape = new THREE.Shape(); const x = 0, y = 0; shape.moveTo(x + 0.25, y + 0.25); shape.bezierCurveTo(x + 0.25, y + 0.25, x + 0.20, y, x, y); shape.bezierCurveTo(x - 0.30, y, x - 0.30, y + 0.35, x - 0.30, y + 0.35); shape.bezierCurveTo(x - 0.30, y + 0.55, x - 0.10, y + 0.77, x + 0.25, y + 0.95); shape.bezierCurveTo(x + 0.60, y + 0.77, x + 0.80, y + 0.55, x + 0.80, y + 0.35); shape.bezierCurveTo(x + 0.80, y + 0.35, x + 0.80, y, x + 0.50, y); shape.bezierCurveTo(x + 0.35, y, x + 0.25, y + 0.25, x + 0.25, y + 0.25);
            const geometry = new THREE.ShapeGeometry(shape); geometry.center(); geometry.scale(1.5, 1.5, 1.5); const material = new THREE.MeshBasicMaterial({ color: 0xFF69B4, transparent: true, opacity: 0.8, side: THREE.DoubleSide, depthTest: false });
            cursorMesh = new THREE.Mesh(geometry, material); cursorMesh.renderOrder = 999; scene.add(cursorMesh); 
        }

        function loadScript(src) { return new Promise((resolve, reject) => { if (document.querySelector(`script[src="${src}"]`)) { resolve(); return; } const s = document.createElement('script'); s.src = src; s.onload = resolve; s.onerror = () => reject(new Error(`Failed to load script: ${src}`)); document.body.appendChild(s); }); }

        async function initMediaPipe() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { alert("ÈîôËØØÔºöÂΩìÂâçÊµèËßàÂô®ÁéØÂ¢É‰∏çÊîØÊåÅËÆøÈóÆÊëÑÂÉèÂ§¥„ÄÇ\nËØ∑Á°Æ‰øùÊÇ®‰ΩøÁî®ÁöÑÊòØ HTTPS ÂçèËÆÆÊàñ localhost Êú¨Âú∞ÁéØÂ¢É„ÄÇ\n(file:/// ÂçèËÆÆÊó†Ê≥ïËÆøÈóÆÊëÑÂÉèÂ§¥)"); return; }
            if(window.mediaPipeInitializing) return;
            if(isCamActive && cameraPipe) { await cameraPipe.stop(); const track = document.getElementById('video-preview').srcObject?.getTracks()[0]; if(track) track.stop(); isCamActive = false; document.getElementById('btn-start-cam').innerText = "üì∑ ÂêØÂä®ÊëÑÂÉèÂ§¥"; document.getElementById('btn-start-cam').classList.remove('active'); document.getElementById('gesture-state').innerText = "Stopped"; return; }
            window.mediaPipeInitializing = true; const btn = document.getElementById('btn-start-cam'); if(btn) btn.innerText = "ÂêØÂä®‰∏≠...";
            const preview = document.getElementById('video-preview');
            const HANDS_VERSION = '0.4.1673521017'; const CAMERA_VERSION = '0.3.1675466862';
            const handsSources = [`https://cdn.jsdelivr.net/npm/@mediapipe/hands@${HANDS_VERSION}/hands.js`, `https://unpkg.com/@mediapipe/hands@${HANDS_VERSION}/hands.js`, `https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js`];
            const cameraSources = [`https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@${CAMERA_VERSION}/camera_utils.js`, `https://unpkg.com/@mediapipe/camera_utils@${CAMERA_VERSION}/camera_utils.js`, `https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js`];
            const loadFromSources = async (sources) => { for (const src of sources) { try { await loadScript(src); return src; } catch (e) { console.warn(`Failed to load ${src}, trying next...`); continue; } } throw new Error("All CDN sources failed."); };
            try {
                const handsLoadedUrl = await loadFromSources(handsSources); const handsBase = handsLoadedUrl.substring(0, handsLoadedUrl.lastIndexOf('/'));
                await loadFromSources(cameraSources);
                hands = new window.Hands({locateFile: (file) => { return `${handsBase}/${file}`; }});
                hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.5, modelComplexity: 0}); 
                hands.onResults(onHandsResults);
                cameraPipe = new window.Camera(preview, { onFrame: async () => { if(isCamActive) await hands.send({image: preview}); }, width: 320, height: 240 });
                await cameraPipe.start();
                isCamActive = true; if(btn) { btn.innerText = "üõë ÂÅúÊ≠¢ÊëÑÂÉèÂ§¥"; btn.classList.add('active'); } document.getElementById('gesture-state').innerText = "Active"; document.getElementById('btn-retry-cam').style.display = 'none';
            } catch(e) {
                console.error("Camera Init Error:", e); let errorMsg = "Êú™Áü•ÈîôËØØ";
                if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') { errorMsg = "ÊùÉÈôêË¢´ÊãíÁªù„ÄÇËØ∑Âú®ÊµèËßàÂô®Âú∞ÂùÄÊ†èÁÇπÂáª'ÈîÅ'ÂõæÊ†áÊàñËÆæÁΩÆ‰∏≠ÂÖÅËÆ∏ÊëÑÂÉèÂ§¥ËÆøÈóÆ„ÄÇ"; } else if (e.name === 'NotFoundError' || e.name === 'DevicesNotFoundError') { errorMsg = "Êú™ÊâæÂà∞ÊëÑÂÉèÂ§¥ËÆæÂ§áÔºåËØ∑Ê£ÄÊü•ËøûÊé•„ÄÇ"; } else if (e.name === 'NotReadableError' || e.name === 'TrackStartError') { errorMsg = "ÊëÑÂÉèÂ§¥ÂèØËÉΩË¢´ÂÖ∂‰ªñÂ∫îÁî®Âç†Áî®ÔºàÂ¶ÇZoom„ÄÅËÖæËÆØ‰ºöËÆÆÔºâÔºåËØ∑ÂÖàÂÖ≥Èó≠ÂÆÉ‰ª¨„ÄÇ"; } else if (window.location.protocol === 'file:') { errorMsg = "ÂÆâÂÖ®ÈôêÂà∂ÔºöÊó†Ê≥ïÂú®Êú¨Âú∞Êñá‰ª∂(file://)‰∏≠ÂêØÂä®ÊëÑÂÉèÂ§¥„ÄÇ\nËØ∑‰ΩøÁî® VS Code ÁöÑ 'Live Server' Êèí‰ª∂ÊâìÂºÄÔºåÊàñÈÉ®ÁΩ≤Âà∞ HTTPS ÁΩëÁ´ô„ÄÇ"; } else { errorMsg = "Âä†ËΩΩÂ§±Ë¥•: " + (e.message || "ÁΩëÁªúÊàñÂÖºÂÆπÊÄßÈóÆÈ¢ò„ÄÇËØ∑Ê£ÄÊü•ÊéßÂà∂Âè∞(F12)Ëé∑ÂèñÊõ¥Â§ö‰ø°ÊÅØ„ÄÇ"); }
                alert("ÊëÑÂÉèÂ§¥ÂêØÂä®Â§±Ë¥•:\n" + errorMsg); document.getElementById('gesture-state').innerText = "Error"; if(btn) { btn.innerText = "ÂêØÂä®ÊëÑÂÉèÂ§¥"; document.getElementById('btn-retry-cam').style.display = 'inline-block'; document.getElementById('btn-retry-cam').onclick = () => { window.mediaPipeInitializing = false; initMediaPipe(); }; }
            } window.mediaPipeInitializing = false;
        }
        window.initMediaPipe = initMediaPipe;

        function onHandsResults(results) {
             if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
             const landmarks = results.multiHandLandmarks[0]; if (!landmarks || landmarks.length < 21) return;
             const thumb = landmarks[4]; const index = landmarks[8]; const middle = landmarks[9]; if (!thumb || !index || !middle) return;
             const pinch = Math.sqrt(Math.pow(thumb.x-index.x, 2) + Math.pow(thumb.y-index.y, 2));
             const rawX = (1 - index.x) * 2 - 1; const rawY = -index.y * 2 + 1; targetHandPointer.x = rawX; targetHandPointer.y = rawY;
             handCentroid.set(middle.x, middle.y);
             let fingersClosed = 0; const tips = [8, 12, 16, 20]; const pips = [6, 10, 14, 18];
             for(let i=0; i<4; i++) { if (landmarks[tips[i]] && landmarks[pips[i]]) { if (landmarks[tips[i]].y > landmarks[pips[i]].y) fingersClosed++; } }
             const isFist = fingersClosed >= 3; const isOpen = fingersClosed <= 1; 
             const now = Date.now(); if (now - lastStateChangeTime < 500) return;
             if (currentState === STATE.EXPLODE && hoveredPhoto) { if (pinch < CONFIG.pinchStart || isFist) { transitionTo(STATE.PHOTO, hoveredPhoto); lastStateChangeTime = now; return; } }
             if (currentState === STATE.PHOTO) { if (pinch > 0.12) { transitionTo(STATE.EXPLODE); lastStateChangeTime = now; } return; }
             if(!isPinching && currentState !== STATE.PHOTO) {
                 if(isFist && currentState !== STATE.PLANET) { transitionTo(STATE.PLANET); lastStateChangeTime = now; }
                 if(isOpen && currentState !== STATE.EXPLODE) { transitionTo(STATE.EXPLODE); lastStateChangeTime = now; }
                 if(currentState === STATE.EXPLODE) { const cx = handCentroid.x - 0.5; if(Math.abs(cx) > CONFIG.camDeadZone) contentGroup.rotation.y += (cx>0?1:-1) * 0.02; }
             }
        }

        function init3DWorld() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x050011, 0.002); 
            contentGroup = new THREE.Group(); orbitGroup = new THREE.Group(); starGroup = new THREE.Group(); scene.add(starGroup); scene.add(contentGroup); scene.add(orbitGroup);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000); camera.position.set(0, 60, 300); 
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = CONFIG.exposureNormal; renderer.outputColorSpace = THREE.SRGBColorSpace; renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; container.appendChild(renderer.domElement);
            const hemiLight = new THREE.HemisphereLight(0xE0B0FF, 0xFF1493, 0.6); scene.add(hemiLight); ambientLight = new THREE.AmbientLight(0xFFE4E1, CONFIG.ambientIntensity); scene.add(ambientLight);
            const mainLight = new THREE.DirectionalLight(0xFFFFFF, 1.5); mainLight.position.set(50, 80, 50); mainLight.castShadow = true; mainLight.shadow.mapSize.width = 2048; mainLight.shadow.mapSize.height = 2048; mainLight.shadow.camera.near = 0.5; mainLight.shadow.camera.far = 500; const d = 50; mainLight.shadow.camera.left = -d; mainLight.shadow.camera.right = d; mainLight.shadow.camera.top = d; mainLight.shadow.camera.bottom = -d; mainLight.shadow.bias = -0.0001; scene.add(mainLight);
            const fillLight = new THREE.DirectionalLight(0xFFB7C5, 0.8); fillLight.position.set(-50, 20, 50); scene.add(fillLight); const backLight = new THREE.DirectionalLight(0x00FFFF, 0.8); backLight.position.set(0, -20, -50); scene.add(backLight);
            const renderScene = new RenderPass(scene, camera); bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), CONFIG.bloomStrengthNormal, 0.5, 0.85); bloomPass.threshold = CONFIG.bloomThreshold; bloomPass.radius = CONFIG.bloomRadius;
            composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);
            controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.autoRotate = true; controls.autoRotateSpeed = CONFIG.spinSpeed; controls.enablePan = false; controls.minPolarAngle = 1.0; controls.maxPolarAngle = 2.0;
            window.addEventListener('resize', onWindowResize); document.getElementById('image-upload').addEventListener('change', handleImageUpload);
            initWorkbench(); initPhotoWorkbench(); createStarField(); createPlanetParticles(); createKittenCore(); createOrbitParticles(); createPiggySatellite(); createCursor(); loadEmbeddedPhotos(); animate();
        }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); }
        function initWorkbench() {
            const updateSceneBrightness = () => { const master = CONFIG.masterBrightness; particleMeshes.forEach(m => { if (m.material) m.material.emissiveIntensity = CONFIG.plushBrightness * master; }); if (coreGroup) { coreGroup.children.forEach(child => { if (child.material && child.material.emissive) { child.material.emissiveIntensity = CONFIG.kittenBrightness * master; } }); } if (satelliteGroup) { satelliteGroup.children.forEach(child => { if (child.material && child.material.emissive) { child.material.emissiveIntensity = 0.2 * master; } }); } if (orbitMeshes.length > 0) { const rainbow = orbitMeshes[0]; if (rainbow && rainbow.material) { rainbow.material.opacity = CONFIG.rainbowIntensity * 0.5 * master; } const cloud = orbitMeshes[1]; if (cloud && cloud.material) { cloud.material.emissiveIntensity = CONFIG.cloudBrightness * master; } } if (ambientLight) { ambientLight.intensity = CONFIG.ambientIntensity * master; } };
            const mapSlider = (id, configKey) => { const el = document.getElementById(id); if(!el) return; el.addEventListener('input', (e) => { const v = parseFloat(e.target.value); CONFIG[configKey] = v; const disp = el.parentElement.querySelector('span'); if(disp) disp.innerText = v.toFixed(1); updateSceneBrightness(); if (configKey === 'spinSpeed') { controls.autoRotateSpeed = v; } if (configKey === 'piggyScale' && satelliteGroup) { satelliteGroup.scale.setScalar(v); } }); };
            const masterSlider = document.getElementById('sl-master'); if(masterSlider) { masterSlider.addEventListener('input', (e) => { CONFIG.masterBrightness = parseFloat(e.target.value); document.getElementById('val-master').innerText = CONFIG.masterBrightness.toFixed(1); updateSceneBrightness(); }); }
            mapSlider('sl-plush', 'plushBrightness'); mapSlider('sl-kitten', 'kittenBrightness'); mapSlider('sl-piggy', 'piggyScale'); mapSlider('sl-cloud', 'cloudBrightness'); mapSlider('sl-rainbow', 'rainbowIntensity'); mapSlider('sl-env', 'ambientIntensity'); mapSlider('sl-spin', 'spinSpeed');
            const btnToggle = document.getElementById('btn-toggle-wb'); const wb = document.getElementById('workbench'); if(btnToggle) btnToggle.onclick = () => { wb.style.display = (wb.style.display === 'none') ? 'block' : 'none'; };
        }
        function initPhotoWorkbench() { const sliderBright = document.getElementById('slider-photo-bright'); const sliderExp = document.getElementById('slider-photo-exp'); sliderBright.addEventListener('input', (e) => { CONFIG.photoBrightnessDim = parseFloat(e.target.value); if(grabbedPhoto) { const m = grabbedPhoto.children.find(c=>c.name==="photo_surface"); if(m) m.material.color.setScalar(CONFIG.photoBrightnessDim); } }); sliderExp.addEventListener('input', (e) => { CONFIG.exposurePhoto = parseFloat(e.target.value); if(currentState === STATE.PHOTO) renderer.toneMappingExposure = CONFIG.exposurePhoto; }); }
        
        function animate() {
            requestAnimationFrame(animate); TWEEN.update(); controls.update(); smoothHandPointer.lerp(targetHandPointer, 0.3);
            if(currentState === STATE.PLANET) { orbitGroup.rotation.y += 0.002; orbitGroup.rotation.z = Math.sin(Date.now()*0.0005)*0.05; if(satelliteGroup) { const time = Date.now() * 0.0005; const r = 90; satelliteGroup.position.x = Math.cos(time) * r; satelliteGroup.position.z = Math.sin(time) * r; satelliteGroup.position.y = Math.sin(time * 2) * 20; satelliteGroup.lookAt(0,0,0); satelliteGroup.rotateZ(time); } if(coreGroup) { const s = 1 + Math.sin(Date.now() * 0.002) * 0.02; coreGroup.scale.setScalar(s); coreGroup.rotation.y -= 0.005; } }
            if (cursorMesh) {
                raycaster.setFromCamera(smoothHandPointer, camera); const defaultCursorPos = raycaster.ray.origin.clone().add(raycaster.ray.direction.multiplyScalar(CONFIG.cursorDistance)); cursorMesh.position.copy(defaultCursorPos); cursorMesh.lookAt(camera.position); cursorMesh.visible = currentState === STATE.EXPLODE;
                if (currentState !== STATE.PLANET && photoObjects.length > 0 && !isPinching && currentState !== STATE.PHOTO) { const intersects = raycaster.intersectObjects(photoObjects, true); if (intersects.length > 0) { let target = intersects[0].object; while(target.parent && target.parent !== contentGroup) target = target.parent; cursorMesh.position.copy(intersects[0].point); if(hoveredPhoto !== target) { if(hoveredPhoto) new TWEEN.Tween(hoveredPhoto.scale).to({x:1, y:1, z:1}, 200).start(); hoveredPhoto = target; new TWEEN.Tween(hoveredPhoto.scale).to({x:1.3, y:1.3, z:1.3}, 200).easing(TWEEN.Easing.Back.Out).start(); } } else if (hoveredPhoto) { new TWEEN.Tween(hoveredPhoto.scale).to({x:1, y:1, z:1}, 200).start(); hoveredPhoto = null; } }
            }
            if (currentState === STATE.PHOTO && grabbedPhoto) {
                camera.updateMatrixWorld(); contentGroup.updateMatrixWorld();
                const viewDistance = 40; const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); const targetWorldPos = camera.position.clone().add(camDir.multiplyScalar(viewDistance));
                const parentInverse = contentGroup.matrixWorld.clone().invert(); const targetLocalPos = targetWorldPos.applyMatrix4(parentInverse);
                grabbedPhoto.position.lerp(targetLocalPos, 0.25); 
                const targetRot = camera.quaternion.clone().premultiply(contentGroup.quaternion.clone().invert()); grabbedPhoto.quaternion.slerp(targetRot, 0.25);
            } composer.render();
        }

        function transitionTo(newState, targetObj = null) {
            if (currentState === newState && grabbedPhoto === targetObj) return;
            isTransitioning = true; currentState = newState; const wb = document.getElementById('photo-workbench');
            if (newState === STATE.PHOTO) { if(wb) wb.style.display = 'block'; controls.autoRotate = false; new TWEEN.Tween(renderer).to({ toneMappingExposure: CONFIG.exposurePhoto }, 800).start(); new TWEEN.Tween(bloomPass).to({ strength: CONFIG.bloomStrengthPhoto }, 800).start(); } else { if(wb) wb.style.display = 'none'; controls.autoRotate = true; new TWEEN.Tween(renderer).to({ toneMappingExposure: CONFIG.exposureNormal }, 800).start(); new TWEEN.Tween(bloomPass).to({ strength: CONFIG.bloomStrengthNormal }, 800).start(); }
            if(targetObj) { grabbedPhoto = targetObj; new TWEEN.Tween(grabbedPhoto.scale).to({x: 1.5, y: 1.5, z: 1.5}, 500).easing(TWEEN.Easing.Cubic.Out).start(); } else { grabbedPhoto = null; photoObjects.forEach(p => { new TWEEN.Tween(p.scale).to({x:1, y:1, z:1}, 500).start(); if(newState === STATE.PLANET) { new TWEEN.Tween(p.position).to(p.userData.originalPos, 1000).easing(TWEEN.Easing.Back.Out).start(); new TWEEN.Tween(p.scale).to({x:0, y:0, z:0}, 1000).start(); } else if (newState === STATE.EXPLODE) { const expPos = p.userData.originalPos.clone().multiplyScalar(1.5); new TWEEN.Tween(p.position).to(expPos, 1000).easing(TWEEN.Easing.Cubic.Out).start(); new TWEEN.Tween(p.scale).to({x:1, y:1, z:1}, 1000).start(); } }); }
            
            const targetPos = newState === STATE.PLANET ? planetPositions : explodePositions; 
            // ‰øÆÊîπÔºöÂ∞ÜÊâ©Êï£ÂÄçÊï∞‰ªé 2.5 ÊèêÂçáÂà∞ 5.0ÔºåËÆ©‰∫ëÊúµÈ£ûÂà∞Áõ∏Êú∫Ë∫´ÂêéÔºåÂÆåÂÖ®‰∏çÈÅÆÊå°ËßÜÁ∫ø
            const orbitScale = newState === STATE.PLANET ? 1 : 5.0;
            
            new TWEEN.Tween({ t: 0 }).to({ t: 1 }, 1500).easing(TWEEN.Easing.Cubic.InOut).onUpdate(({ t }) => { let idx = 0; particleMeshes.forEach(mesh => { for(let i=0; i<mesh.count; i++) { if(idx < targetPos.length) { const start = newState === STATE.PLANET ? explodePositions[idx] : planetPositions[idx]; const end = targetPos[idx]; dummy.position.lerpVectors(start, end, t); dummy.rotation.set(t*Math.PI, t*Math.PI, 0); dummy.updateMatrix(); mesh.setMatrixAt(i, dummy.matrix); idx++; } } mesh.instanceMatrix.needsUpdate = true; }); orbitGroup.scale.setScalar(1 + (orbitScale-1)*t); if(coreGroup) { coreGroup.scale.setScalar(1); } }).onComplete(() => { isTransitioning = false; previousState = newState; }).start();
        }

        // --- Event Listeners Init ---
        // New explicit function to bind events
        function initListeners() {
            const startBtn = document.getElementById('start-gift-btn');
            if(startBtn) startBtn.addEventListener('click', openGift);

            const skipBtn = document.getElementById('skip-intro-btn');
            if(skipBtn) skipBtn.addEventListener('click', endIntro);

            const crawlText = document.getElementById('crawl-text');
            if(crawlText) crawlText.addEventListener('animationend', endIntro);

            const saveBtn = document.getElementById('btn-save-page');
            if(saveBtn) saveBtn.addEventListener('click', savePage);

            const camBtn = document.getElementById('btn-start-cam');
            if(camBtn) camBtn.addEventListener('click', initMediaPipe);
            
            // Note: btn-retry-cam onclick is set dynamically inside initMediaPipe error handler
        }

        // Initialize listeners immediately
        initListeners();

    </script>
</body>
</html>