<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Piggy Planet 3.1 (Star Wars Edition)</title>
    <style>
        /* --- Âü∫Á°ÄËÆæÁΩÆ --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; opacity: 0; transition: opacity 2s ease; }
        
        /* --- 1. Á≤âËâ≤Á§ºÁõíÂú∫ÊôØ --- */
        #intro-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1s;
        }
        .gift-box {
            font-size: 80px; cursor: pointer;
            animation: bounce 2s infinite;
            filter: drop-shadow(0 0 20px #FF69B4);
            transition: transform 0.3s;
        }
        .gift-box:hover { transform: scale(1.1); }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-20px); } }

        /* --- 2. ÊòüÁêÉÂ§ßÊàòÂ≠óÂπïÂú∫ÊôØ --- */
        #starwars-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 90;
            display: none; overflow: hidden; perspective: 400px;
        }
        .stars-bg {
            position: absolute; width: 100%; height: 100%;
            background: url('https://images.unsplash.com/photo-1506318137071-a8bcbf6755dd?q=80&w=2070&auto=format&fit=crop') center/cover;
            opacity: 0.5;
        }
        .intro-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #4BD5EE; font-size: 1.5rem; width: 80%; text-align: center;
            opacity: 0; transition: opacity 1s;
        }
        .crawl-container {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            transform-origin: 50% 100%; transform: rotateX(25deg);
            display: flex; justify-content: center; opacity: 0; transition: opacity 1s;
        }
        .crawl-content {
            position: absolute; top: 100%; width: 80%; max-width: 600px;
            color: #FFD700; font-weight: bold; text-align: justify;
            font-size: 2rem; line-height: 1.5; letter-spacing: 0.1em;
            animation: crawl 25s linear forwards; 
        }
        .crawl-content h1 { text-align: center; font-size: 1.2em; margin-bottom: 0.5em; }
        .crawl-content p { margin-bottom: 1em; }
        @keyframes crawl { 0% { top: 100%; opacity: 1; } 90% { opacity: 1; } 100% { top: -150%; opacity: 0; } }
        .skip-btn {
            position: absolute; bottom: 30px; right: 30px;
            color: #555; border: 1px solid #555; padding: 5px 15px;
            cursor: pointer; z-index: 101; font-size: 0.8rem; background: transparent;
        }
        .skip-btn:hover { color: #fff; border-color: #fff; }

        /* --- 3. UI Overlay --- */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #FFB7C5; pointer-events: none; text-shadow: 0 0 10px #FF69B4;
            display: none; 
        }
        h1 { margin: 0; font-weight: 800; letter-spacing: 2px; text-transform: uppercase; font-size: 1.8rem; background: linear-gradient(to right, #FFB7C5, #E0B0FF); -webkit-background-clip: text; color: transparent; }
        .status { margin-top: 5px; font-size: 0.9rem; color: #E6E6FA; }
        .status span { color: #FFF; font-weight: bold; }

        #video-preview { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; border-radius: 20px; border: 3px solid #FFB7C5; box-shadow: 0 0 20px rgba(255, 105, 180, 0.4); z-index: 10; transform: scaleX(-1); opacity: 0.8; object-fit: cover; display: none; }
        
        #controls { position: absolute; bottom: 20px; left: 20px; z-index: 20; pointer-events: auto; display: none; gap: 10px; flex-wrap: wrap; max-width: 70%;}
        
        button, .btn-upload { font-family: inherit; transition: all 0.2s; outline: none; }
        .btn-upload { background: linear-gradient(135deg, #FF69B4, #FFB7C5); border: none; padding: 12px 24px; color: #fff; font-weight: bold; border-radius: 50px; cursor: pointer; box-shadow: 0 5px 15px rgba(255, 105, 180, 0.4); font-size: 0.9rem; display: inline-block;}
        .btn-upload:hover { transform: scale(1.05); }
        
        .btn-save { background: linear-gradient(135deg, #00FFFF, #1E90FF); border: none; padding: 12px 24px; color: #000; font-weight: bold; border-radius: 50px; cursor: pointer; box-shadow: 0 5px 15px rgba(0, 255, 255, 0.4); font-size: 0.9rem; }
        .btn-save:hover { transform: scale(1.05); box-shadow: 0 0 20px #00FFFF; }

        .btn-cam { background: linear-gradient(135deg, #00FF99, #32CD32); border: none; padding: 12px 24px; color: #000; font-weight: bold; border-radius: 50px; cursor: pointer; box-shadow: 0 5px 15px rgba(0, 255, 153, 0.4); font-size: 0.9rem; }
        .btn-cam:hover { transform: scale(1.05); box-shadow: 0 0 20px #00FF99; }
        .btn-cam.active { background: linear-gradient(135deg, #ff4444, #cc0000); color: white; box-shadow: 0 5px 15px rgba(255, 0, 0, 0.4); }

        .btn-retry { background: rgba(255,255,255,0.1); border: 1px solid #FFB7C5; color: #FFB7C5; padding: 10px; border-radius: 50px; cursor: pointer; display: none; }
        input[type="file"] { display: none; }
        
        /* Workbench & Panels */
        #workbench { position: absolute; top: 70px; right: 20px; width: 260px; background: rgba(20, 10, 30, 0.85); border: 2px solid #FFB7C5; border-radius: 15px; padding: 15px; z-index: 20; color: #FFB7C5; backdrop-filter: blur(10px); font-family: sans-serif; transition: all 0.3s ease; box-shadow: 0 0 20px rgba(0,0,0,0.5); display: none; }
        #workbench h3 { margin: 0 0 15px 0; font-size: 1rem; border-bottom: 1px solid rgba(255,183,197,0.3); padding-bottom: 5px; text-align: center;}
        
        /* ÂàÜÈöîÁ∫øÊ†∑Âºè */
        .separator { border-bottom: 1px dashed rgba(255, 183, 197, 0.3); margin: 10px 0; }
        
        .control-group { margin-bottom: 12px; }
        .control-group label { display: flex; justify-content: space-between; font-size: 0.8rem; margin-bottom: 5px; }
        input[type=range] { width: 100%; accent-color: #FF69B4; cursor: pointer; }
        
        #photo-workbench { position: absolute; top: 50%; right: 20px; transform: translateY(-50%); width: 220px; background: rgba(40, 20, 60, 0.8); border: 2px solid #FFF; border-radius: 15px; padding: 15px; z-index: 20; color: #FFF; font-family: sans-serif; backdrop-filter: blur(5px); display: none; }
        #btn-toggle-wb { position: absolute; top: 20px; right: 20px; width: 40px; height: 40px; border-radius: 50%; background: rgba(20, 10, 30, 0.6); border: 2px solid #FFB7C5; color: #FFB7C5; font-size: 1.2rem; cursor: pointer; z-index: 21; display: none; align-items: center; justify-content: center; transition: all 0.3s; box-shadow: 0 0 10px rgba(255, 105, 180, 0.3); }
        #btn-toggle-wb:hover { background: #FFB7C5; color: #220022; transform: rotate(90deg); }
    </style>
</head>
<body>

    <!-- 1. Á§ºÁõíÂºÄÂú∫ -->
    <div id="intro-layer">
        <div class="gift-box" onclick="openGift()">üéÅ</div>
    </div>

    <!-- 2. ÊòüÁêÉÂ§ßÊàòÂ≠óÂπï -->
    <div id="starwars-layer">
        <div class="stars-bg"></div>
        <div class="intro-text" id="sw-intro-text">
            A long time ago in a galaxy far, far away....
        </div>
        <div class="crawl-container" id="sw-crawl-container" style="opacity: 0;">
            <div class="crawl-content" onanimationend="endIntro()">
                <h1>EPISODE I</h1>
                <h2>THE PIGGY AWAKENS</h2>
                <p>A long time ago... there was a mysterious, mist-shrouded planet.</p>
                <p>It floated in the deep pink nebula, guarded by an ancient Kitten Spirit and a loyal Piggy Satellite.</p>
                <p>Legend has it that this planet holds the most precious memories of the universe...</p>
                <p>Now, the force is strong with you. Use your hands to unlock the magic...</p>
            </div>
        </div>
        <button class="skip-btn" onclick="endIntro()">SKIP >></button>
    </div>

    <!-- 3. Áå™Âí™ÊòüÁêÉ‰∏ªÁïåÈù¢ -->
    <div id="ui-layer">
        <h1>üê∑ Piggy Planet 3.1 üê±</h1>
        <div class="status">STATUS: <span id="sys-status">Initializing...</span></div>
        <div class="status">HANDS: <span id="gesture-state">Searching...</span></div>
    </div>
    
    <button id="btn-toggle-wb" title="ÂàáÊç¢ÊéßÂà∂Âè∞">‚öôÔ∏è</button>

    <div id="workbench">
        <h3>‚ú® Áå™Âí™ÊÄªÊéßÂè∞ ‚ú®</h3>
        <!-- Êñ∞Â¢ûÔºöÊÄªÊéß‰∫ÆÂ∫¶ -->
        <div class="control-group">
            <label style="color:#FFF; font-weight:bold;">üåü Êï¥‰Ωì‰∫ÆÂ∫¶ (Master)<span id="val-master">1.0</span></label>
            <input type="range" id="sl-master" min="0" max="2" step="0.1" value="1.0">
        </div>
        
        <div class="separator"></div>

        <div class="control-group"><label>ÊØõÁªí‰∫ÆÂ∫¶ (Glow)<span id="val-plush">0.5</span></label><input type="range" id="sl-plush" min="0" max="2" step="0.1" value="0.5"></div>
        <div class="control-group"><label>Áå´Âí™‰∫ÆÂ∫¶ (Core)<span id="val-kitten">0.5</span></label><input type="range" id="sl-kitten" min="0" max="2" step="0.1" value="0.5"></div>
        <div class="control-group"><label>Â∞èÁå™Â§ßÂ∞è (Piggy)<span id="val-piggy">1.0</span></label><input type="range" id="sl-piggy" min="0.5" max="3" step="0.1" value="1.0"></div>
        <div class="control-group"><label>‰∫ëÊúµ‰∫ÆÂ∫¶ (Clouds)<span id="val-cloud">0.8</span></label><input type="range" id="sl-cloud" min="0" max="2" step="0.1" value="0.8"></div>
        <div class="control-group"><label>ÂΩ©ËôπÂº∫Â∫¶ (Rainbow)<span id="val-rainbow">1.5</span></label><input type="range" id="sl-rainbow" min="0.5" max="3" step="0.1" value="1.5"></div>
        <div class="control-group"><label>ÁéØÂ¢ÉÂÖâÁÖß (Ambient)<span id="val-env">2.0</span></label><input type="range" id="sl-env" min="0" max="4" step="0.1" value="2.0"></div>
        <div class="control-group"><label>Ëá™ËΩ¨ÈÄüÂ∫¶ (Spin)<span id="val-spin">0.5</span></label><input type="range" id="sl-spin" min="0" max="2" step="0.1" value="0.5"></div>
    </div>

    <div id="photo-workbench">
        <div style="text-align:center; margin-bottom:10px; font-weight:bold;">‚ú® Ë°•ÂÖâÁÅØ ‚ú®</div>
        <div class="control-group"><label>‰∫ÆÂ∫¶<span id="val-photo-bright">0.8</span></label><input type="range" id="slider-photo-bright" min="0" max="2" step="0.05" value="0.8"></div>
        <div class="control-group"><label>ÁéØÂ¢É<span id="val-photo-exp">0.8</span></label><input type="range" id="slider-photo-exp" min="0" max="2" step="0.1" value="0.8"></div>
    </div>

    <div id="controls">
        <label class="btn-upload">‰∏ä‰º†ÁÖßÁâá<input type="file" id="image-upload" multiple accept="image/*"></label>
        <button class="btn-save" onclick="savePage()">üíæ ‰øùÂ≠òÁΩëÈ°µ</button>
        <button id="btn-start-cam" class="btn-cam" onclick="initMediaPipe()">üì∑ ÂêØÂä®ÊëÑÂÉèÂ§¥</button>
        <button id="btn-retry-cam" class="btn-retry">ÈáçËØïÊëÑÂÉèÂ§¥</button>
    </div>

    <!-- ÈáçË¶ÅÔºöÊ∑ªÂä† muted Âíå autoplay Â±ûÊÄß -->
    <video id="video-preview" playsinline muted autoplay></video>
    <div id="canvas-container"></div>
    
    <!-- ËÉåÊôØÈü≥‰πê -->
    <audio id="bgm" loop>
        <source src="https://cdn.pixabay.com/download/audio/2022/03/24/audio_07823d069c.mp3?filename=space-120280.mp3" type="audio/mpeg">
    </audio>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import TWEEN from 'three/addons/libs/tween.module.js';

        // --- Data Persistence ---
        window.EMBEDDED_PHOTOS = [];

        // --- Configuration ---
        const CONFIG = {
            particleCount: 2600, orbitCount: 1200, starCount: 4000, rainbowCount: 800, cloudCount: 600,
            planetRadius: 28, orbitRadius: 45, cloudOrbitRadius: 70, 
            colors: [0xFFC0CB, 0xFFB7C5, 0xFF69B4, 0xFFFFFF, 0xFFE4E1], 
            plushBrightness: 0.5, kittenBrightness: 0.5, piggyScale: 1.0, cloudBrightness: 0.8,
            rainbowIntensity: 1.5, ambientIntensity: 2.0, spinSpeed: 0.5,
            masterBrightness: 1.0, // Êñ∞Â¢ûÔºöÊÄªÊéß‰∫ÆÂ∫¶Á≥ªÊï∞
            bloomStrengthNormal: 1.2, bloomStrengthPhoto: 0.2, bloomThreshold: 0.3, bloomRadius: 0.5,
            pinchStart: 0.06, pinchEnd: 0.10, photoHoverDist: 22, 
            camRotSensitivity: 0.02, camDeadZone: 0.2, cursorDistance: 40,
            photoBrightnessNormal: 1.0, photoBrightnessDim: 0.8, exposureNormal: 1.2, exposurePhoto: 0.8        
        };

        // --- Global Variables ---
        let scene, camera, renderer, composer, controls;
        let contentGroup, orbitGroup, starGroup, coreGroup, satelliteGroup;
        let particleMeshes = [], orbitMeshes = [], photoObjects = [];
        let cursorMesh, ambientLight;
        let bloomPass;
        let dummy = new THREE.Object3D();
        
        // Cache variables to improve performance
        let cachedPlushTexture = null; 

        const raycaster = new THREE.Raycaster();
        const targetHandPointer = new THREE.Vector2(-999, -999);
        const smoothHandPointer = new THREE.Vector2(-999, -999);
        const STATE = { PLANET: 'planet', EXPLODE: 'explode', PHOTO: 'photo' };
        let currentState = STATE.PLANET; let previousState = STATE.PLANET; 
        let isTransitioning = false; let hoveredPhoto = null, grabbedPhoto = null, isPinching = false;
        let planetPositions = [], explodePositions = [];
        let videoElement, hands, cameraPipe; let handCentroid = new THREE.Vector2();
        let mediaPipeInitializing = false;
        let isCamActive = false;
        
        // Êñ∞Â¢ûÔºöÈò≤ÊäñÂä®Êó∂Èó¥Êà≥
        let lastStateChangeTime = 0;

        // --- Save Functionality ---
        window.savePage = function() {
            if (window.EMBEDDED_PHOTOS.length === 0) {
                if(!confirm("ËøòÊ≤°‰∏ä‰º†ÁÖßÁâáÂì¶ÔºåÁ°ÆÂÆöË¶Å‰øùÂ≠òÁ©∫ÊòüÁêÉÂêóÔºü")) return;
            }
            let html = document.documentElement.outerHTML;
            const dataString = JSON.stringify(window.EMBEDDED_PHOTOS);
            
            // ‰øÆÂ§çÔºö‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºèÊõøÊç¢ÔºåÂÖºÂÆπÊÄßÊõ¥Âº∫ÔºàÂÖÅËÆ∏Êú´Â∞æÊ≤°ÊúâÂàÜÂè∑ÁöÑÊÉÖÂÜµÔºâ
            // Êó†ËÆ∫Âéü‰ª£Á†ÅÊòØ window.EMBEDDED_PHOTOS = []; ËøòÊòØ window.EMBEDDED_PHOTOS = ["..."]; ÈÉΩËÉΩË¢´Ê≠£Á°ÆË¶ÜÁõñ„ÄÇ
            html = html.replace(/window\.EMBEDDED_PHOTOS\s*=\s*\[[\s\S]*?\];?/, `window.EMBEDDED_PHOTOS = ${dataString};`);
            
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'piggy_planet_gift.html';
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            alert("ÁΩëÈ°µÂ∑≤‰øùÂ≠òÔºÅ\nÂåÖÂê´ÁÖßÁâáÁöÑÁã¨Á´ãÊñá‰ª∂Â∑≤‰∏ãËΩΩÔºåÊÇ®ÂèØ‰ª•ÊääËøô‰∏™Êñá‰ª∂ÂèëÁªôÂØπÊñπ„ÄÇ");
        };

        // --- Intro Logic ---
        window.openGift = function() {
            const bgm = document.getElementById('bgm');
            bgm.volume = 0.5;
            bgm.play().catch(e => console.log("Audio autoplay blocked - User interaction required later"));

            document.getElementById('intro-layer').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('intro-layer').style.display = 'none';
                startStarWarsIntro();
            }, 1000);
        };

        function startStarWarsIntro() {
            const layer = document.getElementById('starwars-layer');
            const introText = document.getElementById('sw-intro-text');
            const crawlContainer = document.getElementById('sw-crawl-container');
            
            layer.style.display = 'block';
            setTimeout(() => { introText.style.opacity = 1; }, 500);
            setTimeout(() => {
                introText.style.opacity = 0;
                setTimeout(() => {
                    crawlContainer.style.opacity = 1;
                }, 1000);
            }, 4000); 
        }

        window.endIntro = function() {
            const swLayer = document.getElementById('starwars-layer');
            const canvasContainer = document.getElementById('canvas-container');
            const uiLayer = document.getElementById('ui-layer');
            const controls = document.getElementById('controls');
            const preview = document.getElementById('video-preview');
            const btnTog = document.getElementById('btn-toggle-wb');

            swLayer.style.opacity = 0;
            setTimeout(() => {
                swLayer.style.display = 'none';
                if(!window.is3DInitialized) {
                    window.is3DInitialized = true;
                    init3DWorld(); 
                }
                canvasContainer.style.opacity = 1;
                uiLayer.style.display = 'block';
                controls.style.display = 'flex';
                preview.style.display = 'block';
                btnTog.style.display = 'flex';
            }, 1000);
        };

        // --- Resource Management (Expert: Disposal System) ---
        function cleanUpGroup(group) {
            if (!group) return;
            // Iterate backwards to safely remove while traversing
            for (let i = group.children.length - 1; i >= 0; i--) {
                const child = group.children[i];
                cleanUpGroup(child); // Recursive
                
                if (child.geometry) child.geometry.dispose();
                
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => {
                            if (mat.map) mat.map.dispose();
                            if (mat.bumpMap) mat.bumpMap.dispose();
                            mat.dispose();
                        });
                    } else {
                        if (child.material.map) child.material.map.dispose();
                        if (child.material.bumpMap) child.material.bumpMap.dispose();
                        child.material.dispose();
                    }
                }
                group.remove(child);
            }
        }

        // --- Photo Handling ---
        function handleImageUpload(event) {
            const files = event.target.files;
            if (!files.length) return;
            
            // Clean up old photos properly
            photoObjects.forEach(obj => {
                 contentGroup.remove(obj);
                 cleanUpGroup(obj);
            });

            photoObjects = []; window.EMBEDDED_PHOTOS = [];
            
            const loader = new THREE.TextureLoader();
            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const base64 = e.target.result;
                    window.EMBEDDED_PHOTOS.push(base64);
                    // ‰øÆÊîπÔºö‰ΩøÁî®ÂõûË∞ÉÂáΩÊï∞Á°Æ‰øùÂõæÁâáÂä†ËΩΩÂÆåÊàêÔºåËÉΩËé∑ÂèñÂà∞ÂÆΩÈ´ò
                    loader.load(base64, (texture) => {
                        createPhotoFrame(texture, index);
                    });
                };
                reader.readAsDataURL(file);
            });
        }
        
        function loadEmbeddedPhotos() {
            if (window.EMBEDDED_PHOTOS && window.EMBEDDED_PHOTOS.length > 0) {
                const loader = new THREE.TextureLoader();
                window.EMBEDDED_PHOTOS.forEach((data, index) => {
                    // ‰øÆÊîπÔºö‰ΩøÁî®ÂõûË∞ÉÂáΩÊï∞
                    loader.load(data, (texture) => {
                        createPhotoFrame(texture, index);
                    });
                });
            }
        }

        function createPhotoFrame(texture, index) {
            // Adjust texture encoding for latest Three.js color management
            texture.colorSpace = THREE.SRGBColorSpace;
            
            // --- Ê†∏ÂøÉ‰øÆÊîπÔºöËá™ÈÄÇÂ∫îÂÆΩÈ´òÊØî‰æã ---
            const img = texture.image;
            let width = 8;
            let height = 8;
            const maxDim = 9; // ÊúÄÂ§ßËæπÈïøÈôêÂà∂ÔºåÈò≤Ê≠¢ÈïøÂõæËøáÂ§ß

            if (img.width && img.height) {
                const aspect = img.width / img.height;
                if (aspect >= 1) {
                    // Ê®™ÂõæÔºöÂÆΩÂ∫¶Âõ∫ÂÆö‰∏∫ maxDimÔºåÈ´òÂ∫¶Ëá™ÈÄÇÂ∫î
                    width = maxDim;
                    height = maxDim / aspect;
                } else {
                    // Á´ñÂõæÔºöÈ´òÂ∫¶Âõ∫ÂÆö‰∏∫ maxDimÔºåÂÆΩÂ∫¶Ëá™ÈÄÇÂ∫î
                    height = maxDim;
                    width = maxDim * aspect;
                }
            }

            // ‰ΩøÁî®ËÆ°ÁÆóÂá∫ÁöÑ width Âíå height ÂàõÂª∫Âá†‰Ωï‰Ωì
            const photoGeo = new THREE.PlaneGeometry(width, height);
            const photoMat = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide, 
                color: new THREE.Color().setScalar(CONFIG.photoBrightnessNormal) 
            });
            const photoMesh = new THREE.Mesh(photoGeo, photoMat); 
            photoMesh.name = "photo_surface"; 
            
            const frameGroup = new THREE.Group(); 
            frameGroup.add(photoMesh);
            
            // --- ÊùêË¥®‰øÆÊîπÔºöÊ∑°Á≤âÁ∫¢Ëâ≤‰∏çÂèçÂÖâÊØõÁªíÊùêË¥® ---
            const plushTex = getPlushTexture(); // Â§çÁî®Â∑≤ÊúâÁöÑÊØõÁªíÁ∫πÁêÜÁîüÊàêÂô®
            
            const frameMat = new THREE.MeshPhysicalMaterial({ 
                color: 0xFFB7C5,       // Ê∑°Á≤âÁ∫¢Ëâ≤ (Pale Pink)
                roughness: 1.0,        // Á≤óÁ≥ôÂ∫¶ËÆæ‰∏∫ 1.0 (ÂÆåÂÖ®‰∏çÂèçÂÖâ/ÂìëÂÖâ)
                metalness: 0.0,        // ÈùûÈáëÂ±û
                bumpMap: plushTex,     // Ê∑ªÂä†ÂáπÂá∏Á∫πÁêÜÊ®°ÊãüÊØõÁªíË°®Èù¢
                bumpScale: 0.5,        // Â¢ûÂä†ÂáπÂá∏Ê∑±Â∫¶
                sheen: 1.0,            // ÂºÄÂêØÂÖâÊ≥ΩÂ±Ç (Ê®°ÊãüÁªáÁâ©ËæπÁºòÁöÑÊ≥õÂÖâ)
                sheenColor: 0xFFE4E1,  // Ê≥õÂÖâÈ¢úËâ≤‰∏∫Êõ¥Ê∑°ÁöÑÁ≤âÁôΩ
                sheenRoughness: 1.0,   // Ê≥õÂÖâ‰πüÂæàÊüîÂíå
                clearcoat: 0.0         // ÂÖ≥Èó≠Ê∏ÖÊºÜÂ±Ç (ÂéªÈô§Â°ëÊñôÊÑü)
            });
            
            const thickness = 0.5; const depth = 0.3; 
            const w = width; 
            const h = height;
            
            // Ê†πÊçÆÂä®ÊÄÅÁöÑ w Âíå h ÊûÑÂª∫ËæπÊ°Ü
            const topBar = new THREE.Mesh(new THREE.BoxGeometry(w+thickness*2, thickness, depth), frameMat); topBar.position.y = h/2+thickness/2;
            const bottomBar = new THREE.Mesh(new THREE.BoxGeometry(w+thickness*2, thickness, depth), frameMat); bottomBar.position.y = -h/2-thickness/2;
            const leftBar = new THREE.Mesh(new THREE.BoxGeometry(thickness, h, depth), frameMat); leftBar.position.x = -w/2-thickness/2;
            const rightBar = new THREE.Mesh(new THREE.BoxGeometry(thickness, h, depth), frameMat); rightBar.position.x = w/2+thickness/2;
            
            [topBar, bottomBar, leftBar, rightBar].forEach(b => { 
                b.name = "frame_border"; 
                b.castShadow = true;
                b.receiveShadow = true;
                frameGroup.add(b); 
            });
            
            const theta = Math.random()*Math.PI*2; 
            const phi = Math.acos((Math.random()*2)-1); 
            const r = CONFIG.planetRadius + 15; 
            frameGroup.position.set(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
            frameGroup.lookAt(0,0,0);
            frameGroup.userData = { originalPos: frameGroup.position.clone(), originalRot: frameGroup.rotation.clone(), id: index, baseScale: 1.0 };
            
            // Photo Visibility: Start Hidden if in Planet Mode
            if(currentState === STATE.PLANET) frameGroup.scale.set(0,0,0);
            
            contentGroup.add(frameGroup); 
            photoObjects.push(frameGroup);
        }

        // --- Texture Generation (Expert: Caching) ---
        function getPlushTexture() {
            if (cachedPlushTexture) return cachedPlushTexture;
            
            const size = 512; 
            const canvas = document.createElement('canvas'); 
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d'); 
            ctx.fillStyle = '#808080'; ctx.fillRect(0, 0, size, size);
            
            const imgData = ctx.getImageData(0, 0, size, size); const data = imgData.data;
            for(let i = 0; i < data.length; i += 4) { 
                const val = 128 + (Math.random() - 0.5) * 50; 
                data[i] = val; data[i+1] = val; data[i+2] = val; 
            }
            ctx.putImageData(imgData, 0, 0); 
            
            cachedPlushTexture = new THREE.CanvasTexture(canvas); 
            cachedPlushTexture.wrapS = THREE.RepeatWrapping; 
            cachedPlushTexture.wrapT = THREE.RepeatWrapping; 
            return cachedPlushTexture;
        }

        // --- 3D Object Creation ---
        function createKittenCore() {
            cleanUpGroup(coreGroup); 
            if(coreGroup) contentGroup.remove(coreGroup);
            coreGroup = new THREE.Group();
            
            const r = CONFIG.planetRadius * 0.5; 
            const plushTex = getPlushTexture();

            // EXPERT TWEAK: Use Physical Material for Sheen (Velvet Effect)
            const matPink = new THREE.MeshPhysicalMaterial({ 
                color: 0xFFB7C5, 
                roughness: 0.8, 
                bumpMap: plushTex, 
                bumpScale: 0.2, 
                emissive: 0xFF69B4, 
                emissiveIntensity: CONFIG.kittenBrightness * CONFIG.masterBrightness, // Apply Master
                sheen: 1.0, 
                sheenColor: 0xFFFFFF,
                sheenRoughness: 0.5
            });

            const matDarkPink = new THREE.MeshStandardMaterial({ color: 0xFF1493 }); 
            const matBlack = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.1 }); 
            const matWhite = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });

            const head = new THREE.Mesh(new THREE.SphereGeometry(r, 64, 64), matPink); 
            head.castShadow = true; head.receiveShadow = true;
            coreGroup.add(head);

            const earGeo = new THREE.ConeGeometry(r*0.35, r*0.5, 32); 
            const e1 = new THREE.Mesh(earGeo, matPink); e1.position.set(-r*0.5, r*0.75, 0); e1.rotation.z = 0.4; e1.rotation.x = -0.1; e1.castShadow = true;
            const e2 = new THREE.Mesh(earGeo, matPink); e2.position.set(r*0.5, r*0.75, 0); e2.rotation.z = -0.4; e2.rotation.x = -0.1; e2.castShadow = true;
            coreGroup.add(e1); coreGroup.add(e2);

            const eyeGeo = new THREE.SphereGeometry(r*0.18, 32, 32); 
            const eyeL = new THREE.Mesh(eyeGeo, matBlack); eyeL.position.set(-r*0.4, r*0.1, r*0.82); 
            const spL = new THREE.Mesh(new THREE.SphereGeometry(r*0.06), matWhite); spL.position.set(r*0.08, r*0.08, r*0.15); eyeL.add(spL); coreGroup.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, matBlack); eyeR.position.set(r*0.4, r*0.1, r*0.82); 
            const spR = new THREE.Mesh(new THREE.SphereGeometry(r*0.06), matWhite); spR.position.set(r*0.08, r*0.08, r*0.15); eyeR.add(spR); coreGroup.add(eyeR);

            const cheekGeo = new THREE.SphereGeometry(r*0.15); 
            const matBlush = new THREE.MeshBasicMaterial({ color: 0xFF69B4, transparent: true, opacity: 0.6 }); 
            const cheekL = new THREE.Mesh(cheekGeo, matBlush); cheekL.position.set(-r*0.55, -r*0.15, r*0.75); coreGroup.add(cheekL); 
            const cheekR = new THREE.Mesh(cheekGeo, matBlush); cheekR.position.set(r*0.55, -r*0.15, r*0.75); coreGroup.add(cheekR);
            
            // --- NEW: Whiskers (Áå´ËÉ°Â≠ê) ---
            const whiskerMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8 });
            const whiskerGeo = new THREE.CylinderGeometry(0.1, 0.05, r*0.8, 8);
            whiskerGeo.translate(0, r*0.4, 0); // Move pivot to one end
            whiskerGeo.rotateZ(Math.PI/2);     // Orient horizontally
            
            const createWhiskerSide = (isLeft) => {
                const group = new THREE.Group();
                const sign = isLeft ? 1 : -1;
                // Position group near the cheek
                group.position.set(sign * r * 0.6, -r * 0.05, r * 0.7);
                // Rotate slightly to face forward/out
                group.rotation.y = sign * 0.3;
                
                for(let i=-1; i<=1; i++) {
                    const w = new THREE.Mesh(whiskerGeo, whiskerMat);
                    // Fan them out
                    w.rotation.z = i * 0.2 + (isLeft ? 0 : Math.PI); 
                    w.rotation.y = (Math.random()-0.5) * 0.2;
                    group.add(w);
                }
                return group;
            };
            
            coreGroup.add(createWhiskerSide(true));  // Left whiskers
            coreGroup.add(createWhiskerSide(false)); // Right whiskers

            const nose = new THREE.Mesh(new THREE.CapsuleGeometry(r*0.06, r*0.1, 4, 8), matDarkPink); 
            nose.rotation.z = Math.PI/2; nose.position.set(0, -r*0.05, r*0.95); coreGroup.add(nose);
            
            contentGroup.add(coreGroup);
        }

        function createPlanetParticles() {
            // Dispose old meshes properly
            particleMeshes.forEach(m => { contentGroup.remove(m); if(m.geometry) m.geometry.dispose(); if(m.material) m.material.dispose(); });
            particleMeshes = []; planetPositions = []; explodePositions = [];
            
            const plushTex = getPlushTexture();
            
            // EXPERT TWEAK: Physical Material for Particles
            const matSphere = new THREE.MeshPhysicalMaterial({ 
                color: 0xFFFFFF, 
                roughness: 0.9, 
                bumpMap: plushTex, 
                bumpScale: 0.2, 
                emissive: 0xFF69B4, 
                emissiveIntensity: CONFIG.plushBrightness * CONFIG.masterBrightness, // Apply Master
                sheen: 1.0,
                sheenColor: 0xFFC0CB
            });
            
            const matBox = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF, roughness: 0.4, metalness: 0.3, emissive: 0x442244, emissiveIntensity: 0.2 
            });
            
            const sphereGeo = new THREE.IcosahedronGeometry(0.9, 1); // Reduced resolution slightly for performance
            const boxGeo = new THREE.BoxGeometry(1.3, 1.3, 1.3);      
            
            const sphereCount = Math.floor(CONFIG.particleCount * 0.7); 
            const boxCount = CONFIG.particleCount - sphereCount;
            
            const meshSphere = new THREE.InstancedMesh(sphereGeo, matSphere, sphereCount); 
            meshSphere.castShadow = true; meshSphere.receiveShadow = true;
            
            const meshBox = new THREE.InstancedMesh(boxGeo, matBox, boxCount);
            meshBox.castShadow = true; meshBox.receiveShadow = true;

            meshSphere.userData = { type: 'sphere' }; meshBox.userData = { type: 'box' };
            const meshes = [meshSphere, meshBox]; const counts = [sphereCount, boxCount]; const color = new THREE.Color();
            
            const phi = Math.PI * (3 - Math.sqrt(5)); const total = CONFIG.particleCount;
            let allPos = [];
            
            // Fibonacci Sphere Distribution
            for(let i=0; i<total; i++) { 
                const y = 1 - (i / (total - 1)) * 2; 
                const radiusAtY = Math.sqrt(1 - y * y); 
                const theta = phi * i; 
                const x = Math.cos(theta) * radiusAtY; 
                const z = Math.sin(theta) * radiusAtY; 
                const r = CONFIG.planetRadius + (Math.random() - 0.5) * 2.0; 
                allPos.push(new THREE.Vector3(x*r, y*r, z*r)); 
            }
            
            // Shuffle
            const indices = Array.from({length: total}, (_, i) => i); 
            for(let i=indices.length-1; i>0; i--) { const j = Math.floor(Math.random() * (i+1)); [indices[i], indices[j]] = [indices[j], indices[i]]; }
            
            let offset = 0;
            meshes.forEach((mesh, idx) => {
                const count = counts[idx];
                for(let i=0; i<count; i++) {
                    const pIdx = indices[offset + i]; 
                    const pos = allPos[pIdx]; 
                    planetPositions.push(pos);
                    const rExp = 50 + Math.random() * 50; 
                    explodePositions.push(pos.clone().normalize().multiplyScalar(rExp));
                    
                    dummy.position.copy(pos); 
                    dummy.scale.setScalar(Math.random()*0.5 + 0.5); 
                    dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                    dummy.updateMatrix(); 
                    mesh.setMatrixAt(i, dummy.matrix);
                    
                    const hex = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)]; 
                    color.setHex(hex); 
                    mesh.setColorAt(i, color);
                }
                offset += count; 
                contentGroup.add(mesh); 
                particleMeshes.push(mesh);
            });
        }

        function createOrbitParticles() {
            cleanUpGroup(orbitGroup);
            orbitMeshes = [];
            
            const geo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 * CONFIG.rainbowIntensity * 0.5 * CONFIG.masterBrightness, blending: THREE.AdditiveBlending });
            const rainbowMesh = new THREE.InstancedMesh(geo, mat, CONFIG.rainbowCount);
            
            const colors = [0xFF0000, 0xFFA500, 0xFFFF00, 0x00FF00, 0x00FFFF, 0x0000FF, 0x8B00FF]; 
            const col = new THREE.Color();
            
            for(let i=0; i<CONFIG.rainbowCount; i++) {
                const t = i / CONFIG.rainbowCount; const angle = t * Math.PI * 2;
                const r = CONFIG.orbitRadius + (Math.random()-0.5) * 6; 
                const x = Math.cos(angle) * r; const z = Math.sin(angle) * r; 
                const y = Math.sin(angle * 3) * 5 + (Math.random()-0.5)*2; 
                
                dummy.position.set(x, y, z); 
                dummy.scale.setScalar(Math.random() * 1.5 + 0.5); 
                dummy.rotation.set(Math.random(), Math.random(), Math.random()); 
                dummy.updateMatrix();
                rainbowMesh.setMatrixAt(i, dummy.matrix);
                
                const cIdx = Math.floor(t * colors.length); 
                col.setHex(colors[cIdx]); col.lerp(new THREE.Color(0xFFFFFF), 0.3); 
                rainbowMesh.setColorAt(i, col);
            }
            orbitGroup.add(rainbowMesh); orbitMeshes.push(rainbowMesh);
            
            const cloudMat = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF, roughness: 1, flatShading: false, transparent: true, opacity: 0.8, 
                emissive: 0xFFFFFF, emissiveIntensity: CONFIG.cloudBrightness * CONFIG.masterBrightness 
            });
            const cloudGeo = new THREE.SphereGeometry(2.5, 8, 8); 
            const cloudsTotal = CONFIG.cloudCount * 5; 
            const cloudMesh = new THREE.InstancedMesh(cloudGeo, cloudMat, cloudsTotal);
            
            let idx = 0;
            for(let i=0; i<CONFIG.cloudCount; i++) {
                const angle = Math.random() * Math.PI * 2; const rCenter = CONFIG.cloudOrbitRadius; 
                if(Math.random() > 0.4) continue; 
                const centerX = Math.cos(angle) * rCenter; const centerZ = Math.sin(angle) * rCenter; const centerY = (Math.random()-0.5) * 9; 
                const blobs = 4 + Math.floor(Math.random() * 4);
                
                for(let j=0; j<blobs; j++) {
                    if(idx >= cloudsTotal) break;
                    const offX = (Math.random()-0.5)*6; const offY = (Math.random()-0.5)*1.8; const offZ = (Math.random()-0.5)*6;
                    dummy.position.set(centerX + offX, centerY + offY, centerZ + offZ); 
                    dummy.scale.setScalar(Math.random() * 1.5 + 0.8);
                    dummy.rotation.set(Math.random(), Math.random(), 0); 
                    dummy.updateMatrix(); 
                    cloudMesh.setMatrixAt(idx, dummy.matrix); 
                    cloudMesh.setColorAt(idx, new THREE.Color(0xFFFFFF)); 
                    idx++;
                }
            }
            orbitGroup.add(cloudMesh); orbitMeshes.push(cloudMesh);
        }

        function createPiggySatellite() {
            if(satelliteGroup) orbitGroup.remove(satelliteGroup); 
            // Satellite is usually kept simple, so we just remove from parent, cleaner can handle next refresh
            satelliteGroup = new THREE.Group();
            
            const size = 3.5;
            const matPink = new THREE.MeshPhysicalMaterial({ 
                color: 0xFFB7C5, roughness: 0.6, metalness: 0.1, 
                emissive: 0xFFC0CB, emissiveIntensity: 0.2 * CONFIG.masterBrightness,
                clearcoat: 0.5
            });
            const matDark = new THREE.MeshStandardMaterial({ color: 0xFF69B4 }); 
            const matBlack = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const body = new THREE.Mesh(new THREE.SphereGeometry(size, 32, 32), matPink); body.castShadow = true; satelliteGroup.add(body);
            const earGeo = new THREE.ConeGeometry(size*0.4, size*0.8, 16);
            const e1 = new THREE.Mesh(earGeo, matPink); e1.position.set(-size*0.6, size*0.7, 0); e1.rotation.z = 0.5; body.add(e1);
            const e2 = new THREE.Mesh(earGeo, matPink); e2.position.set(size*0.6, size*0.7, 0); e2.rotation.z = -0.5; body.add(e2);
            
            const snout = new THREE.Mesh(new THREE.CylinderGeometry(size*0.3, size*0.35, size*0.2, 16), matDark); 
            snout.rotation.x = Math.PI/2; snout.position.set(0, 0, size*0.9); body.add(snout);
            
            const eye1 = new THREE.Mesh(new THREE.SphereGeometry(size*0.12), matBlack); eye1.position.set(-size*0.4, size*0.2, size*0.85); body.add(eye1);
            const eye2 = new THREE.Mesh(new THREE.SphereGeometry(size*0.12), matBlack); eye2.position.set(size*0.4, size*0.2, size*0.85); body.add(eye2);
            
            satelliteGroup.scale.setScalar(CONFIG.piggyScale); 
            orbitGroup.add(satelliteGroup);
        }

        function createStarField() {
            const starGeo = new THREE.BufferGeometry(); const starPos = [];
            for(let i=0; i<CONFIG.starCount; i++) {
                const r = 400 + Math.random() * 400; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                starPos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 1.5, transparent: true, opacity: 0.8, sizeAttenuation: true });
            const stars = new THREE.Points(starGeo, starMat); 
            starGroup.add(stars);
        }

        function createCursor() {
            const shape = new THREE.Shape(); const x = 0, y = 0;
            shape.moveTo(x + 0.25, y + 0.25); shape.bezierCurveTo(x + 0.25, y + 0.25, x + 0.20, y, x, y);
            shape.bezierCurveTo(x - 0.30, y, x - 0.30, y + 0.35, x - 0.30, y + 0.35); shape.bezierCurveTo(x - 0.30, y + 0.55, x - 0.10, y + 0.77, x + 0.25, y + 0.95);
            shape.bezierCurveTo(x + 0.60, y + 0.77, x + 0.80, y + 0.55, x + 0.80, y + 0.35); shape.bezierCurveTo(x + 0.80, y + 0.35, x + 0.80, y, x + 0.50, y);
            shape.bezierCurveTo(x + 0.35, y, x + 0.25, y + 0.25, x + 0.25, y + 0.25);
            
            const geometry = new THREE.ShapeGeometry(shape); geometry.center(); geometry.scale(1.5, 1.5, 1.5); 
            const material = new THREE.MeshBasicMaterial({ color: 0xFF69B4, transparent: true, opacity: 0.8, side: THREE.DoubleSide, depthTest: false });
            cursorMesh = new THREE.Mesh(geometry, material); cursorMesh.renderOrder = 999; scene.add(cursorMesh); 
        }

        // --- Helper: Dynamic Script Loading ---
        // EXPERT TWEAK: Removed crossOrigin="anonymous" to prevent CORS issues on some CDNs
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                if (document.querySelector(`script[src="${src}"]`)) { resolve(); return; }
                const s = document.createElement('script');
                s.src = src; 
                // Removed s.crossOrigin = "anonymous"; here
                s.onload = resolve; 
                s.onerror = () => reject(new Error(`Failed to load script: ${src}`)); 
                document.body.appendChild(s);
            });
        }

        // --- MediaPipe Implementation ---
        async function initMediaPipe() {
            // ÂÆâÂÖ®Ê£ÄÊü•ÔºöÂ¶ÇÊûúÊµèËßàÂô®‰∏çÊîØÊåÅÂ™í‰ΩìËÆæÂ§áÔºà‰æãÂ¶ÇÂú®ÈùûÂÆâÂÖ®‰∏ä‰∏ãÊñá‰∏≠ÔºâÔºåÁõ¥Êé•Êä•Èîô
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert("ÈîôËØØÔºöÂΩìÂâçÊµèËßàÂô®ÁéØÂ¢É‰∏çÊîØÊåÅËÆøÈóÆÊëÑÂÉèÂ§¥„ÄÇ\nËØ∑Á°Æ‰øùÊÇ®‰ΩøÁî®ÁöÑÊòØ HTTPS ÂçèËÆÆÊàñ localhost Êú¨Âú∞ÁéØÂ¢É„ÄÇ\n(file:/// ÂçèËÆÆÊó†Ê≥ïËÆøÈóÆÊëÑÂÉèÂ§¥)");
                return;
            }

            if(window.mediaPipeInitializing) return;
            
            // Toggle Logic if already active
            if(isCamActive && cameraPipe) {
                // Stop camera
                await cameraPipe.stop();
                const track = document.getElementById('video-preview').srcObject?.getTracks()[0];
                if(track) track.stop();
                isCamActive = false;
                document.getElementById('btn-start-cam').innerText = "üì∑ ÂêØÂä®ÊëÑÂÉèÂ§¥";
                document.getElementById('btn-start-cam').classList.remove('active');
                document.getElementById('gesture-state').innerText = "Stopped";
                return;
            }

            window.mediaPipeInitializing = true;
            const btn = document.getElementById('btn-start-cam');
            if(btn) btn.innerText = "ÂêØÂä®‰∏≠...";
            
            const preview = document.getElementById('video-preview');
            
            // CDN Fallback Logic (Expert Update: Added Latest fallback)
            const HANDS_VERSION = '0.4.1673521017';
            const CAMERA_VERSION = '0.3.1675466862';
            
            // List of sources in order of preference
            const handsSources = [
                `https://cdn.jsdelivr.net/npm/@mediapipe/hands@${HANDS_VERSION}/hands.js`,
                `https://unpkg.com/@mediapipe/hands@${HANDS_VERSION}/hands.js`,
                `https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js` // Fallback to latest
            ];

            const cameraSources = [
                `https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@${CAMERA_VERSION}/camera_utils.js`,
                `https://unpkg.com/@mediapipe/camera_utils@${CAMERA_VERSION}/camera_utils.js`,
                `https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js` // Fallback to latest
            ];

            // Helper to try loading from a list of URLs
            const loadFromSources = async (sources) => {
                for (const src of sources) {
                    try {
                        await loadScript(src);
                        console.log(`Successfully loaded: ${src}`);
                        return src; // Return the working URL to determine base path
                    } catch (e) {
                        console.warn(`Failed to load ${src}, trying next...`);
                        continue;
                    }
                }
                throw new Error("All CDN sources failed.");
            };

            try {
                console.log("Loading MediaPipe scripts...");
                
                // Load Hands
                const handsLoadedUrl = await loadFromSources(handsSources);
                // Determine base URL for assets based on which script loaded
                const handsBase = handsLoadedUrl.substring(0, handsLoadedUrl.lastIndexOf('/'));

                // Load Camera Utils
                await loadFromSources(cameraSources);
                
                console.log("Initializing Hands...");
                if(!window.Hands) throw new Error("Hands library not found after script load");

                hands = new window.Hands({locateFile: (file) => {
                    return `${handsBase}/${file}`;
                }});
                
                hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.5, modelComplexity: 0}); 
                hands.onResults(onHandsResults);

                console.log("Initializing Camera...");
                if(!window.Camera) throw new Error("Camera library not found after script load");

                cameraPipe = new window.Camera(preview, {
                    onFrame: async () => { if(isCamActive) await hands.send({image: preview}); },
                    width: 320, height: 240
                });
                
                await cameraPipe.start();
                console.log("Camera started successfully.");
                
                isCamActive = true;
                if(btn) {
                    btn.innerText = "üõë ÂÅúÊ≠¢ÊëÑÂÉèÂ§¥";
                    btn.classList.add('active');
                } 
                document.getElementById('gesture-state').innerText = "Active";
                document.getElementById('btn-retry-cam').style.display = 'none';

            } catch(e) {
                console.error("Camera Init Error:", e);
                let errorMsg = "Êú™Áü•ÈîôËØØ";
                
                if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') {
                    errorMsg = "ÊùÉÈôêË¢´ÊãíÁªù„ÄÇËØ∑Âú®ÊµèËßàÂô®Âú∞ÂùÄÊ†èÁÇπÂáª'ÈîÅ'ÂõæÊ†áÊàñËÆæÁΩÆ‰∏≠ÂÖÅËÆ∏ÊëÑÂÉèÂ§¥ËÆøÈóÆ„ÄÇ";
                } else if (e.name === 'NotFoundError' || e.name === 'DevicesNotFoundError') {
                    errorMsg = "Êú™ÊâæÂà∞ÊëÑÂÉèÂ§¥ËÆæÂ§áÔºåËØ∑Ê£ÄÊü•ËøûÊé•„ÄÇ";
                } else if (e.name === 'NotReadableError' || e.name === 'TrackStartError') {
                    errorMsg = "ÊëÑÂÉèÂ§¥ÂèØËÉΩË¢´ÂÖ∂‰ªñÂ∫îÁî®Âç†Áî®ÔºàÂ¶ÇZoom„ÄÅËÖæËÆØ‰ºöËÆÆÔºâÔºåËØ∑ÂÖàÂÖ≥Èó≠ÂÆÉ‰ª¨„ÄÇ";
                } else if (window.location.protocol === 'file:') {
                    errorMsg = "ÂÆâÂÖ®ÈôêÂà∂ÔºöÊó†Ê≥ïÂú®Êú¨Âú∞Êñá‰ª∂(file://)‰∏≠ÂêØÂä®ÊëÑÂÉèÂ§¥„ÄÇ\nËØ∑‰ΩøÁî® VS Code ÁöÑ 'Live Server' Êèí‰ª∂ÊâìÂºÄÔºåÊàñÈÉ®ÁΩ≤Âà∞ HTTPS ÁΩëÁ´ô„ÄÇ";
                } else {
                    errorMsg = "Âä†ËΩΩÂ§±Ë¥•: " + (e.message || "ÁΩëÁªúÊàñÂÖºÂÆπÊÄßÈóÆÈ¢ò„ÄÇËØ∑Ê£ÄÊü•ÊéßÂà∂Âè∞(F12)Ëé∑ÂèñÊõ¥Â§ö‰ø°ÊÅØ„ÄÇ");
                }
                
                alert("ÊëÑÂÉèÂ§¥ÂêØÂä®Â§±Ë¥•:\n" + errorMsg);
                
                document.getElementById('gesture-state').innerText = "Error";
                if(btn) {
                    btn.innerText = "ÂêØÂä®ÊëÑÂÉèÂ§¥";
                    document.getElementById('btn-retry-cam').style.display = 'inline-block';
                    document.getElementById('btn-retry-cam').onclick = () => { window.mediaPipeInitializing = false; initMediaPipe(); };
                }
            }
            window.mediaPipeInitializing = false;
        }
        window.initMediaPipe = initMediaPipe;

        function onHandsResults(results) {
             // Basic validity check
             if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
             
             const landmarks = results.multiHandLandmarks[0];
             // Ensure we have enough landmarks (MediaPipe Hands has 21)
             if (!landmarks || landmarks.length < 21) return;

             const thumb = landmarks[4]; 
             const index = landmarks[8];
             const middle = landmarks[9]; // Hand centroid approx

             if (!thumb || !index || !middle) return;

             // ËÆ°ÁÆóÊãáÊåáÂíåÈ£üÊåáÁöÑË∑ùÁ¶ª
             const pinch = Math.sqrt(Math.pow(thumb.x-index.x, 2) + Math.pow(thumb.y-index.y, 2));
             
             // Smoothing the pointer movement
             const rawX = (1 - index.x) * 2 - 1;
             const rawY = -index.y * 2 + 1;
             targetHandPointer.x = rawX; targetHandPointer.y = rawY;
             
             handCentroid.set(middle.x, middle.y);
             
             // Improved Gesture Detection (4 Fingers)
             let fingersClosed = 0;
             const tips = [8, 12, 16, 20];
             const pips = [6, 10, 14, 18];
             
             for(let i=0; i<4; i++) {
                 // Safety check for landmarks in loop
                 if (landmarks[tips[i]] && landmarks[pips[i]]) {
                     if (landmarks[tips[i]].y > landmarks[pips[i]].y) fingersClosed++;
                 }
             }
             
             // Detection Logic
             const isFist = fingersClosed >= 3; 
             const isOpen = fingersClosed <= 1; 
             
             // --- Ê†∏ÂøÉ‰øÆÂ§çÔºöÊõ¥Á®≥ÂÆöÁöÑÁä∂ÊÄÅÊú∫ ---
             const now = Date.now();
             // Â¶ÇÊûúÂàöÂàöÂèëÁîü‰∫ÜÁä∂ÊÄÅÂàáÊç¢ÔºåÁªô 500ms ÁöÑÂÜ∑Âç¥Êó∂Èó¥ÔºåÈò≤Ê≠¢ÂèçÂ§çË∑≥Âèò
             if (now - lastStateChangeTime < 500) return;

             // 1. ÁÖßÁâáÈÄâÊã© (ÂæÆËßÇ‰∫§‰∫í)
             // Êù°‰ª∂ÔºöÂú® EXPLODE Áä∂ÊÄÅ + ÊåáÈíàÊÇ¨ÂÅúÂú®ÁÖßÁâá‰∏ä + (ÊçèÂêàË∑ùÁ¶ªÂ§üÂ∞è Êàñ Êè°Êã≥)
             if (currentState === STATE.EXPLODE && hoveredPhoto) {
                 if (pinch < CONFIG.pinchStart || isFist) {
                     transitionTo(STATE.PHOTO, hoveredPhoto);
                     lastStateChangeTime = now;
                     return; 
                 }
             }

             // 2. ÁÖßÁâáÂΩí‰Ωç (Deselect)
             // Êù°‰ª∂ÔºöÂú® PHOTO Áä∂ÊÄÅ + ÊçèÂêàË∑ùÁ¶ªÂèòÂ§ß (Âç≥ÊùæÊâã)
             // ‰øÆÂ§çÁÇπÔºöËøôÈáå‰∏çÂÜç‰ΩøÁî® isOpen Âà§Êñ≠ÔºåÂõ†‰∏∫ÊçèÂêàÊâãÂäøÊú¨Ë∫´Â∏∏Ë¢´ËØØÂà§‰∏∫ isOpen
             if (currentState === STATE.PHOTO) {
                 // Âè™ÊúâÂΩìÊçèÂêàË∑ùÁ¶ªÊòéÁ°ÆÂèòÂ§ßÔºàÊâãÊåáÂº†ÂºÄÔºâÊó∂ÊâçÈÄÄÂá∫
                 // ÈòàÂÄºÁ®çÂæÆÊîæÂÆΩ‰∏ÄÁÇπ (0.12) ‰ª•Â¢ûÂä†ÂÆπÈîô
                 if (pinch > 0.12) { 
                     transitionTo(STATE.EXPLODE);
                     lastStateChangeTime = now;
                 }
                 return; // Âè™Ë¶ÅÂú®ÁúãÁÖßÁâáÔºåÂ∞±ÈîÅÂÆöÂú®ËøôÈáåÔºå‰∏çÊâßË°åÂêéÈù¢ÁöÑÊòüÁêÉÈÄªËæë
             }
             
             // 3. ÂÖ®Â±ÄÊòüÁêÉÊéßÂà∂ (ÂÆèËßÇ‰∫§‰∫í)
             // Âè™Êúâ‰∏çÂú®ÁúãÁÖßÁâá„ÄÅ‰πüÊ≤°Âú®ÊçèÂêàÊó∂ÊâçÊ£ÄÊµã
             if(!isPinching && currentState !== STATE.PHOTO) {
                 // ÊçèÊã≥ -> ËÅöÊã¢
                 if(isFist && currentState !== STATE.PLANET) {
                     transitionTo(STATE.PLANET);
                     lastStateChangeTime = now;
                 }
                 
                 // ÊùæÊâã -> Êï£ÂºÄ
                 if(isOpen && currentState !== STATE.EXPLODE) {
                     transitionTo(STATE.EXPLODE);
                     lastStateChangeTime = now;
                 }
                 
                 if(currentState === STATE.EXPLODE) { 
                     const cx = handCentroid.x - 0.5; 
                     if(Math.abs(cx) > CONFIG.camDeadZone) contentGroup.rotation.y += (cx>0?1:-1) * 0.02; 
                 }
             }
        }

        // --- Main Scene Setup ---
        function init3DWorld() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene(); 
            scene.fog = new THREE.FogExp2(0x050011, 0.002); 
            
            contentGroup = new THREE.Group(); 
            orbitGroup = new THREE.Group(); 
            starGroup = new THREE.Group();    
            scene.add(starGroup); scene.add(contentGroup); scene.add(orbitGroup);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000); 
            camera.position.set(0, 60, 300); 
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" }); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
            
            // Color Correction
            renderer.toneMapping = THREE.ACESFilmicToneMapping; 
            renderer.toneMappingExposure = CONFIG.exposureNormal; 
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            
            // Shadows (Expert Upgrade)
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            container.appendChild(renderer.domElement);
            
            // Lighting Setup
            const hemiLight = new THREE.HemisphereLight(0xE0B0FF, 0xFF1493, 0.6); 
            scene.add(hemiLight);
            
            ambientLight = new THREE.AmbientLight(0xFFE4E1, CONFIG.ambientIntensity); 
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xFFFFFF, 1.5); 
            mainLight.position.set(50, 80, 50); 
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 500;
            const d = 50;
            mainLight.shadow.camera.left = -d; mainLight.shadow.camera.right = d; mainLight.shadow.camera.top = d; mainLight.shadow.camera.bottom = -d;
            mainLight.shadow.bias = -0.0001;
            scene.add(mainLight);
            
            const fillLight = new THREE.DirectionalLight(0xFFB7C5, 0.8); 
            fillLight.position.set(-50, 20, 50); 
            scene.add(fillLight);
            
            const backLight = new THREE.DirectionalLight(0x00FFFF, 0.8); 
            backLight.position.set(0, -20, -50); 
            scene.add(backLight);

            // Post Processing
            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), CONFIG.bloomStrengthNormal, 0.5, 0.85);
            bloomPass.threshold = CONFIG.bloomThreshold; 
            bloomPass.radius = CONFIG.bloomRadius;
            
            composer = new EffectComposer(renderer); 
            composer.addPass(renderScene); 
            composer.addPass(bloomPass);

            controls = new OrbitControls(camera, renderer.domElement); 
            controls.enableDamping = true; 
            controls.autoRotate = true; 
            controls.autoRotateSpeed = CONFIG.spinSpeed;
            controls.enablePan = false; 
            controls.minPolarAngle = 1.0; 
            controls.maxPolarAngle = 2.0;

            // Events
            window.addEventListener('resize', onWindowResize);
            document.getElementById('image-upload').addEventListener('change', handleImageUpload);
            
            initWorkbench(); 
            initPhotoWorkbench();
            
            createStarField(); 
            createPlanetParticles(); 
            createKittenCore(); 
            createOrbitParticles(); 
            createPiggySatellite(); 
            createCursor(); 
            loadEmbeddedPhotos(); 
            
            animate();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- UI & Logic ---
        function initWorkbench() {
            // Helper to apply brightness multipliers
            const updateSceneBrightness = () => {
                const master = CONFIG.masterBrightness;
                
                // Plush
                particleMeshes.forEach(m => {
                    if (m.material) m.material.emissiveIntensity = CONFIG.plushBrightness * master;
                });
                
                // Kitten Core
                if (coreGroup) {
                    coreGroup.children.forEach(child => {
                        // Check for materials with emissive property (MeshPhysicalMaterial, MeshStandardMaterial)
                        if (child.material && child.material.emissive) {
                            // Apply base intensity * master
                            // Note: We need to know the base intensity. 
                            // Since we don't store base separately on the mesh, we use CONFIG value
                            // This assumes all core parts share the same base kittenBrightness setting
                            child.material.emissiveIntensity = CONFIG.kittenBrightness * master;
                        }
                    });
                }
                
                // Piggy Satellite
                if (satelliteGroup) {
                    satelliteGroup.children.forEach(child => {
                         if (child.material && child.material.emissive) {
                             // Piggy has a hardcoded base intensity of 0.2 in createPiggySatellite
                             // We don't have a specific slider for Piggy Brightness (only scale), 
                             // but let's say it follows Ambient or just Master
                             child.material.emissiveIntensity = 0.2 * master;
                         }
                    });
                }
                
                // Clouds & Rainbows (Orbit Group)
                if (orbitMeshes.length > 0) {
                    // Rainbow (Index 0) - opacity control
                    const rainbow = orbitMeshes[0];
                    if (rainbow && rainbow.material) {
                        rainbow.material.opacity = CONFIG.rainbowIntensity * 0.5 * master;
                    }
                    
                    // Cloud (Index 1) - emissive
                    const cloud = orbitMeshes[1];
                    if (cloud && cloud.material) {
                        cloud.material.emissiveIntensity = CONFIG.cloudBrightness * master;
                    }
                }
                
                // Ambient Light
                if (ambientLight) {
                    ambientLight.intensity = CONFIG.ambientIntensity * master;
                }
            };

            // Slider Logic with Master Multiplier
            const mapSlider = (id, configKey) => {
                const el = document.getElementById(id);
                if(!el) return;
                el.addEventListener('input', (e) => {
                    const v = parseFloat(e.target.value);
                    CONFIG[configKey] = v;
                    
                    // Update display value
                    const disp = el.parentElement.querySelector('span');
                    if(disp) disp.innerText = v.toFixed(1);
                    
                    // Trigger global update
                    updateSceneBrightness();
                    
                    // Special case: Spin Speed is not a brightness setting
                    if (configKey === 'spinSpeed') {
                        controls.autoRotateSpeed = v;
                    }
                    // Special case: Piggy Scale
                    if (configKey === 'piggyScale' && satelliteGroup) {
                        satelliteGroup.scale.setScalar(v);
                    }
                });
            };
            
            // Register Listeners
            const masterSlider = document.getElementById('sl-master');
            if(masterSlider) {
                masterSlider.addEventListener('input', (e) => {
                    CONFIG.masterBrightness = parseFloat(e.target.value);
                    document.getElementById('val-master').innerText = CONFIG.masterBrightness.toFixed(1);
                    updateSceneBrightness();
                });
            }

            mapSlider('sl-plush', 'plushBrightness');
            mapSlider('sl-kitten', 'kittenBrightness');
            mapSlider('sl-piggy', 'piggyScale');
            mapSlider('sl-cloud', 'cloudBrightness');
            mapSlider('sl-rainbow', 'rainbowIntensity');
            mapSlider('sl-env', 'ambientIntensity');
            mapSlider('sl-spin', 'spinSpeed');
            
            const btnToggle = document.getElementById('btn-toggle-wb');
            const wb = document.getElementById('workbench');
            if(btnToggle) btnToggle.onclick = () => { wb.style.display = (wb.style.display === 'none') ? 'block' : 'none'; };
        }

        function initPhotoWorkbench() {
             const sliderBright = document.getElementById('slider-photo-bright');
             const sliderExp = document.getElementById('slider-photo-exp');
             sliderBright.addEventListener('input', (e) => {
                 CONFIG.photoBrightnessDim = parseFloat(e.target.value);
                 if(grabbedPhoto) { const m = grabbedPhoto.children.find(c=>c.name==="photo_surface"); if(m) m.material.color.setScalar(CONFIG.photoBrightnessDim); }
             });
             sliderExp.addEventListener('input', (e) => {
                 CONFIG.exposurePhoto = parseFloat(e.target.value);
                 if(currentState === STATE.PHOTO) renderer.toneMappingExposure = CONFIG.exposurePhoto;
             });
        }

        // --- Animation & States ---
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update(); 
            controls.update(); 
            smoothHandPointer.lerp(targetHandPointer, 0.3);

            if(currentState === STATE.PLANET) {
                orbitGroup.rotation.y += 0.002; 
                orbitGroup.rotation.z = Math.sin(Date.now()*0.0005)*0.05; 
                if(satelliteGroup) {
                    const time = Date.now() * 0.0005; const r = 90; 
                    satelliteGroup.position.x = Math.cos(time) * r; satelliteGroup.position.z = Math.sin(time) * r; satelliteGroup.position.y = Math.sin(time * 2) * 20; 
                    satelliteGroup.lookAt(0,0,0); satelliteGroup.rotateZ(time); 
                }
                if(coreGroup) {
                    const s = 1 + Math.sin(Date.now() * 0.002) * 0.02; coreGroup.scale.setScalar(s); coreGroup.rotation.y -= 0.005; 
                }
            }

            // Raycasting logic for interactivity
            if (cursorMesh) {
                raycaster.setFromCamera(smoothHandPointer, camera);
                const defaultCursorPos = raycaster.ray.origin.clone().add(raycaster.ray.direction.multiplyScalar(CONFIG.cursorDistance));
                cursorMesh.position.copy(defaultCursorPos); cursorMesh.lookAt(camera.position);
                
                // Cursor Visibility: Only visible in EXPLODE state (Hide in PHOTO mode)
                cursorMesh.visible = currentState === STATE.EXPLODE;

                if (currentState !== STATE.PLANET && photoObjects.length > 0 && !isPinching && currentState !== STATE.PHOTO) {
                      const intersects = raycaster.intersectObjects(photoObjects, true);
                      if (intersects.length > 0) {
                          let target = intersects[0].object; while(target.parent && target.parent !== contentGroup) target = target.parent;
                          
                          // --- Magnetic Effect (Á£ÅÂê∏‰ΩìÊÑü) ---
                          cursorMesh.position.copy(intersects[0].point); 
                          
                          if(hoveredPhoto !== target) {
                              if(hoveredPhoto) new TWEEN.Tween(hoveredPhoto.scale).to({x:1, y:1, z:1}, 200).start();
                              hoveredPhoto = target; 
                              // Scale up effect
                              new TWEEN.Tween(hoveredPhoto.scale).to({x:1.3, y:1.3, z:1.3}, 200).easing(TWEEN.Easing.Back.Out).start();
                          }
                      } else if (hoveredPhoto) { 
                          new TWEEN.Tween(hoveredPhoto.scale).to({x:1, y:1, z:1}, 200).start(); hoveredPhoto = null; 
                      }
                }
            }
            
            // --- Ê†∏ÂøÉ‰øÆÊîπÔºöÊ≤âÊµ∏ÂºèÁÖßÁâáÊü•ÁúãÈÄªËæë (Immersive View) ---
            if (currentState === STATE.PHOTO && grabbedPhoto) {
                // 1. Á°Æ‰øùÁü©ÈòµÊòØÊúÄÊñ∞ÁöÑÔºåÈò≤Ê≠¢ËÆ°ÁÆóÂÅèÂ∑Æ
                camera.updateMatrixWorld();
                contentGroup.updateMatrixWorld();

                // 2. ËÆ°ÁÆóÁõÆÊ†á‰ΩçÁΩÆÔºöÁõ∏Êú∫Ê≠£ÂâçÊñπÂõ∫ÂÆöË∑ùÁ¶ª
                // ‰ΩøÁî®ËæÉÂ§ßÁöÑË∑ùÁ¶ªÁ°Æ‰øùÁÖßÁâá‰∏ç‰ºöË¢´Áõ∏Êú∫ËøëË£ÅÂâ™Èù¢Ë£ÅÂâ™
                const viewDistance = 40; 
                const camDir = new THREE.Vector3(); 
                camera.getWorldDirection(camDir);
                const targetWorldPos = camera.position.clone().add(camDir.multiplyScalar(viewDistance));
                
                // 3. ÂùêÊ†áËΩ¨Êç¢Ôºö‰∏ñÁïåÂùêÊ†á -> contentGroup Êú¨Âú∞ÂùêÊ†á
                // ËøôÊ†∑Êó†ËÆ∫ contentGroup ÊÄé‰πàÊóãËΩ¨ÔºåÁÖßÁâáÈÉΩËÉΩÂáÜÁ°ÆÂÅúÂú®Áõ∏Êú∫Èù¢Ââç
                const parentInverse = contentGroup.matrixWorld.clone().invert(); 
                const targetLocalPos = targetWorldPos.applyMatrix4(parentInverse);
                
                // 4. ÁßªÂä®ÁÖßÁâáÔºöÂ¢ûÂä† lerp ÈÄüÂ∫¶ (0.25) ËÆ©Ë∑üÈöèÊõ¥Á¥ßÊâãÔºåÂáèÂ∞ëÊãñÊãΩÊÑü
                grabbedPhoto.position.lerp(targetLocalPos, 0.25); 
                
                // 5. ÂßøÊÄÅÈîÅÂÆöÔºöËÆ©ÁÖßÁâáÂπ≥Èù¢ÂÆåÂÖ®Âπ≥Ë°å‰∫éÁõ∏Êú∫Âπ≥Èù¢
                // Áõ∏ÊØî lookAtÔºå‰ΩøÁî®ÂõõÂÖÉÊï∞Êã∑Ë¥ùËÉΩ‰øùËØÅÁÖßÁâáÁªùÂØπÊ∞¥Âπ≥Á´ØÊ≠£Ôºå‰∏ç‰ºöÊúâÈÄèËßÜÊ≠™Êñú
                // ËÆ°ÁÆóÔºöÁÖßÁâáÊóãËΩ¨ = Áõ∏Êú∫ÊóãËΩ¨ * Áà∂Á∫ßÈÄÜÊóãËΩ¨ (ÊäµÊ∂àÁà∂Á∫ßÂΩ±Âìç)
                const targetRot = camera.quaternion.clone().premultiply(contentGroup.quaternion.clone().invert());
                grabbedPhoto.quaternion.slerp(targetRot, 0.25);
            }
            composer.render();
        }

        function transitionTo(newState, targetObj = null) {
            // Èò≤Ê≠¢Âú®Áõ∏ÂêåÁä∂ÊÄÅ‰∏ãÈáçÂ§çËß¶Âèë (Debounce)
            if (currentState === newState && grabbedPhoto === targetObj) return;

            isTransitioning = true; currentState = newState;
            const wb = document.getElementById('photo-workbench');

            if (newState === STATE.PHOTO) {
                if(wb) wb.style.display = 'block';
                // ËøõÂÖ•ÁÖßÁâáÊ®°ÂºèÔºöÊöÇÂÅúËá™Âä®ÊóãËΩ¨ÔºåÊèê‰æõÁ®≥ÂÆöËßÇÊÑü
                controls.autoRotate = false;
                
                new TWEEN.Tween(renderer).to({ toneMappingExposure: CONFIG.exposurePhoto }, 800).start();
                new TWEEN.Tween(bloomPass).to({ strength: CONFIG.bloomStrengthPhoto }, 800).start();
            } else {
                if(wb) wb.style.display = 'none';
                // ÈÄÄÂá∫ÁÖßÁâáÊ®°ÂºèÔºöÊÅ¢Â§çÊóãËΩ¨
                controls.autoRotate = true; 

                new TWEEN.Tween(renderer).to({ toneMappingExposure: CONFIG.exposureNormal }, 800).start();
                new TWEEN.Tween(bloomPass).to({ strength: CONFIG.bloomStrengthNormal }, 800).start();
            }

            if(targetObj) {
                grabbedPhoto = targetObj;
                // ÈÄâ‰∏≠Êó∂ÊîæÂ§ßÔºåÊèêÂçáËßÜËßâ‰∏≠ÂøÉÊÑü
                new TWEEN.Tween(grabbedPhoto.scale).to({x: 1.5, y: 1.5, z: 1.5}, 500).easing(TWEEN.Easing.Cubic.Out).start();
            } else {
                grabbedPhoto = null;
                photoObjects.forEach(p => {
                    // Reset Scale
                    new TWEEN.Tween(p.scale).to({x:1, y:1, z:1}, 500).start();
                    
                    if(newState === STATE.PLANET) { 
                        // Back to Original Position
                        new TWEEN.Tween(p.position).to(p.userData.originalPos, 1000).easing(TWEEN.Easing.Back.Out).start(); 
                        new TWEEN.Tween(p.scale).to({x:0, y:0, z:0}, 1000).start();
                    } 
                    else if (newState === STATE.EXPLODE) { 
                        const expPos = p.userData.originalPos.clone().multiplyScalar(1.5); 
                        new TWEEN.Tween(p.position).to(expPos, 1000).easing(TWEEN.Easing.Cubic.Out).start(); 
                        new TWEEN.Tween(p.scale).to({x:1, y:1, z:1}, 1000).start(); 
                    }
                });
            }

            const targetPos = newState === STATE.PLANET ? planetPositions : explodePositions;
            const orbitScale = newState === STATE.PLANET ? 1 : 2.5;
            
            new TWEEN.Tween({ t: 0 }).to({ t: 1 }, 1500).easing(TWEEN.Easing.Cubic.InOut)
                .onUpdate(({ t }) => {
                    let idx = 0; 
                    particleMeshes.forEach(mesh => {
                        for(let i=0; i<mesh.count; i++) {
                            // Interpolate only if target exists
                            if(idx < targetPos.length) {
                                const start = newState === STATE.PLANET ? explodePositions[idx] : planetPositions[idx];
                                const end = targetPos[idx];
                                dummy.position.lerpVectors(start, end, t); 
                                dummy.rotation.set(t*Math.PI, t*Math.PI, 0); 
                                dummy.updateMatrix(); mesh.setMatrixAt(i, dummy.matrix); 
                                idx++;
                            }
                        }
                        mesh.instanceMatrix.needsUpdate = true;
                    });
                    orbitGroup.scale.setScalar(1 + (orbitScale-1)*t);
                    if(coreGroup) { coreGroup.scale.setScalar(1); }
                }).onComplete(() => { isTransitioning = false; previousState = newState; }).start();
        }

    </script>
</body>
</html>